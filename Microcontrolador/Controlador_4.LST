CCS PCM C Compiler, Version 3.203, 16465

               Filename: J:\Controle Estufa\Controlador_4.LST

               ROM used: 6604 words (81%)
                         Largest free fragment is 966
               RAM used: 62 (35%) at main() level
                         139 (79%) worst case
               Stack:    5 locations

*
0000:  MOVLW  18
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
....................  //Arquivo de definição para o 16F877  
.................... #include <16f877.h> 
....................  //////// Standard Header file for the PIC16F877 device ////////////////  
.................... #device PIC16F877  
.................... #list  
....................  
....................   
.................... //Ajusta os fusiveis (XT=Oscilador de Cristal) (No Watch Dog Timer) (Power Up Time)  
.................... #fuses XT,NOWDT,PUT  
....................   
.................... //Configura a velocidade para 4MHz  
.................... #use delay(clock=4000000)  
*
0075:  MOVLW  70
0076:  MOVWF  04
0077:  MOVF   00,W
0078:  BTFSC  03.2
0079:  GOTO   089
007A:  MOVLW  01
007B:  MOVWF  78
007C:  CLRF   77
007D:  DECFSZ 77,F
007E:  GOTO   07D
007F:  DECFSZ 78,F
0080:  GOTO   07C
0081:  MOVLW  4A
0082:  MOVWF  77
0083:  DECFSZ 77,F
0084:  GOTO   083
0085:  NOP
0086:  NOP
0087:  DECFSZ 00,F
0088:  GOTO   07A
0089:  RETLW  00
.................... //Configura o módulo interno de I2C  
.................... #use i2c(master, sda=pin_d0, scl=pin_d1)  
*
0416:  MOVLW  08
0417:  MOVWF  78
0418:  NOP
0419:  NOP
041A:  BCF    08.1
041B:  BSF    03.5
041C:  BCF    08.1
041D:  NOP
041E:  RLF    20,F
041F:  BCF    03.5
0420:  BCF    08.0
0421:  BTFSS  03.0
0422:  GOTO   426
0423:  BSF    03.5
0424:  BSF    08.0
0425:  BCF    03.5
0426:  BTFSC  03.0
0427:  GOTO   42B
0428:  BSF    03.5
0429:  BCF    08.0
042A:  BCF    03.5
042B:  BSF    03.5
042C:  BSF    08.1
042D:  BCF    03.5
042E:  BTFSC  08.1
042F:  GOTO   432
0430:  BSF    03.5
0431:  GOTO   42D
0432:  DECFSZ 78,F
0433:  GOTO   418
0434:  NOP
0435:  BCF    08.1
0436:  BSF    03.5
0437:  BCF    08.1
0438:  NOP
0439:  BSF    08.0
043A:  NOP
043B:  NOP
043C:  BSF    08.1
043D:  BCF    03.5
043E:  BTFSC  08.1
043F:  GOTO   442
0440:  BSF    03.5
0441:  GOTO   43D
0442:  CLRF   78
0443:  NOP
0444:  BTFSC  08.0
0445:  BSF    78.0
0446:  BCF    08.1
0447:  BSF    03.5
0448:  BCF    08.1
0449:  BCF    03.5
044A:  BCF    08.0
044B:  BSF    03.5
044C:  BCF    08.0
044D:  BCF    03.5
044E:  RETLW  00
*
0739:  MOVLW  08
073A:  BSF    03.5
073B:  MOVWF  20
073C:  MOVF   77,W
073D:  MOVWF  21
073E:  BSF    08.0
073F:  NOP
0740:  BSF    08.1
0741:  BCF    03.5
0742:  BTFSC  08.1
0743:  GOTO   746
0744:  BSF    03.5
0745:  GOTO   741
0746:  BTFSC  08.0
0747:  BSF    03.0
0748:  BTFSS  08.0
0749:  BCF    03.0
074A:  RLF    78,F
074B:  NOP
074C:  BSF    03.5
074D:  BCF    08.1
074E:  BCF    03.5
074F:  BCF    08.1
0750:  BSF    03.5
0751:  DECFSZ 20,F
0752:  GOTO   73E
0753:  BSF    08.0
0754:  NOP
0755:  BCF    03.5
0756:  BCF    08.0
0757:  BSF    03.5
0758:  MOVF   21,W
0759:  BTFSS  03.2
075A:  BCF    08.0
075B:  NOP
075C:  BSF    08.1
075D:  BCF    03.5
075E:  BTFSC  08.1
075F:  GOTO   762
0760:  BSF    03.5
0761:  GOTO   75D
0762:  NOP
0763:  BCF    08.1
0764:  BSF    03.5
0765:  BCF    08.1
0766:  NOP
0767:  BCF    03.5
0768:  BCF    08.0
0769:  BSF    03.5
076A:  BCF    08.0
076B:  BCF    03.5
076C:  RETLW  00
.................... //Configura o módulo interno de comunicação Serial com o PC  
.................... #use rs232(baud=9600, parity=N, bits=8, xmit=pin_c6, rcv=pin_c7, stream=PC)  
....................   
.................... //Define os pinos do bus I2C  
.................... #define sda          pin_d0  
.................... #define scl          pin_d1  
.................... #define EEPROM_SDA   pin_d0  
.................... #define EEPROM_SCL   pin_d1  
....................   
.................... //Define os pinos de comunicacao com o sensor de temperatura/umidade  
.................... #define sht_data     pin_a0  
.................... #define sck          pin_a1  
....................   
.................... //Definição dos pinos para o display  
.................... #define  lcd_enable  pin_b0   //Pino de ENABLE do LCD  
.................... #define  lcd_rs      pin_b1   //Pino de RS do LCD  
.................... #define  lcd_db4     pin_d4   //Pino de dados d4 do LCD  
.................... #define  lcd_db5     pin_d5   //Pino de dados d5 do LCD  
.................... #define  lcd_db6     pin_d6   //Pino de dados d6 do LCD  
.................... #define  lcd_db7     pin_d7   //Pino de dados d7 do LCD  
....................   
.................... // Define o pino do Led piscante  
.................... #define led          pin_b7  
....................   
.................... //Define o pino do Rele da Bomba  
.................... #define rele         pin_c1  
.................... //Define os pinos das linhas de irrigação  
.................... #define linha1       pin_b5  
.................... #define linha2       pin_b4  
....................   
.................... // Define onde estão as duas teclas  
.................... #define tecla1       !input(pin_c2)  
.................... #define tecla2       !input(pin_c3)  
....................   
.................... //Variavel que guarda a posicao da memoria  
.................... long mem_pos=0;  
*
180F:  CLRF   20
1810:  CLRF   21
.................... // Variavel que vai receber os caracteres da serial CM:01:12:12:30#  
.................... char buffer[18];  
....................   
.................... //Arquivo com biblioteca de funcoes I2C  
.................... #include <i2c.h> 
....................  /*****************************************************************/  
.................... /*  I2C.C                                                        */  
.................... /*  Biblioteca I2C - Comunicação I2C por software com suporte    */  
.................... /*  a memórias EEPROM (modo mestre)                              */  
.................... /*                                                               */  
.................... /*  Autor: Fábio Pereira                                         */  
.................... /*                                                               */  
.................... /*****************************************************************/  
....................   
.................... #ifndef scl  
.................... 	// Definições dos pinos de comunicação  
.................... 	#define scl  pin_b1		     // pino de clock  
.................... 	#define sda  pin_b0		     // pino de dados  
.................... #endif  
....................   
.................... #ifndef EEPROM_SIZE  
....................    #define EEPROM_SIZE 8192    // tamanho em bytes da memória EEPROM (8192 x 8bits)  
.................... #endif  
....................   
.................... #define seta_scl   output_float(scl)		// seta o pino scl  
.................... #define apaga_scl  output_low(scl)		   // apaga o pino scl  
.................... #define seta_sda   output_float(sda)		// seta o pino sda  
.................... #define apaga_sda  output_low(sda)	    	// apaga o pino sda  
....................   
.................... void I2C_start(void)  
.................... // coloca o barramento na condição de start  
.................... {  
.................... 	apaga_scl;  // coloca a linha de clock em nível 0  
.................... 	seta_sda;	// coloca a linha de dados em alta impedância (1)  
.................... 	seta_scl;	// coloca a linha de clock em alta impedância (1)  
.................... 	apaga_sda;	// coloca a linha de dados em nível 0  
.................... 	apaga_scl;	// coloca a linha de clock em nível 0  
.................... }  
.................... void I2C_stop(void)  
.................... // coloca o barramento na condição de stop  
.................... {  
.................... 	apaga_scl;	// coloca a linha de clock em nível 0  
.................... 	apaga_sda;	// coloca a linha de dados em nível 0  
.................... 	seta_scl;	// coloca a linha de clock em alta impedância (1)  
.................... 	seta_sda;	// coloca a linha de dados em alta impedância (1)  
.................... }  
.................... void i2c_ack()  
.................... // coloca sinal de reconhecimento (ack) no barramento  
.................... {  
.................... 	apaga_sda;	// coloca a linha de dados em nível 0  
.................... 	seta_scl;	// coloca a linha de clock em alta impedância (1)  
.................... 	apaga_scl;	// coloca a linha de clock em nível 0  
.................... 	seta_sda;	// coloca a linha de dados em alta impedância (1)  
.................... }  
.................... void i2c_nack()  
.................... // coloca sinal de não reconhecimento (nack) no barramento  
.................... {  
.................... 	seta_sda;	// coloca a linha de dados em alta impedância (1)  
*
0358:  BSF    03.5
0359:  BSF    08.0
.................... 	seta_scl;	// coloca a linha de clock em alta impedância (1)  
035A:  BSF    08.1
.................... 	apaga_scl;	// coloca a linha de clock em nível 0  
035B:  BCF    08.1
035C:  BCF    03.5
035D:  BCF    08.1
.................... }  
....................   
.................... // Verifica se a memoria esta OK  
.................... BOOLEAN ext_eeprom_ready() {  
....................    int1 ack;  
....................    i2c_start();            // Se o comando de escrita for reconhecido,  
*
044F:  BSF    03.5
0450:  BSF    08.0
0451:  NOP
0452:  BSF    08.1
0453:  NOP
0454:  BCF    03.5
0455:  BCF    08.0
0456:  BSF    03.5
0457:  BCF    08.0
0458:  NOP
0459:  BCF    03.5
045A:  BCF    08.1
045B:  BSF    03.5
045C:  BCF    08.1
....................    ack = i2c_write(0xa0);  // entao o dispositivo esta pronto.  
045D:  MOVLW  A0
045E:  MOVWF  20
045F:  BCF    03.5
0460:  CALL   416
0461:  MOVF   78,W
0462:  BTFSC  78.0
0463:  GOTO   466
0464:  BCF    69.0
0465:  GOTO   467
0466:  BSF    69.0
....................    i2c_stop();  
0467:  BSF    03.5
0468:  BCF    08.0
0469:  NOP
046A:  BSF    08.1
046B:  BCF    03.5
046C:  BTFSC  08.1
046D:  GOTO   470
046E:  BSF    03.5
046F:  GOTO   46B
0470:  NOP
0471:  NOP
0472:  NOP
0473:  NOP
0474:  BSF    03.5
0475:  BSF    08.0
0476:  NOP
....................    return !ack;  
0477:  MOVLW  00
0478:  BCF    03.5
0479:  BTFSS  69.0
047A:  MOVLW  01
047B:  MOVWF  78
.................... }  
....................   
.................... boolean i2c_le_ack()  
.................... // efetua a leitura do sinal de ack/nack  
.................... {  
.................... 	boolean estado;  
.................... 	seta_sda; 	// coloca a linha de dados em alta impedância (1)  
*
02E9:  BSF    03.5
02EA:  BSF    08.0
.................... 	seta_scl;	// coloca a linha de clock em alta impedância (1)  
02EB:  BSF    08.1
.................... 	estado = input(sda);	// lê o bit (ack/nack)  
02EC:  BSF    08.0
02ED:  BCF    70.0
02EE:  BCF    03.5
02EF:  BTFSC  08.0
02F0:  BSF    70.0
.................... 	apaga_scl;	// coloca a linha de clock em nível 0  
02F1:  BSF    03.5
02F2:  BCF    08.1
02F3:  BCF    03.5
02F4:  BCF    08.1
.................... 	return estado;  
02F5:  MOVLW  00
02F6:  BTFSC  70.0
02F7:  MOVLW  01
02F8:  MOVWF  78
.................... }  
02F9:  RETLW  00
.................... void I2C_escreve_byte(unsigned char dado)  
.................... {  
.................... // envia um byte pelo barramento I2C  
.................... 	int conta=8;  
*
02C9:  MOVLW  08
02CA:  MOVWF  73
.................... 	apaga_scl;		// coloca SCL em 0  
02CB:  BSF    03.5
02CC:  BCF    08.1
02CD:  BCF    03.5
02CE:  BCF    08.1
.................... 	while (conta)  
.................... 	{  
02CF:  MOVF   73,F
02D0:  BTFSC  03.2
02D1:  GOTO   2E5
.................... 		// envia primeiro o MSB  
.................... 		if (shift_left(&dado,1,0)) seta_sda; else apaga_sda;  
02D2:  BCF    03.0
02D3:  RLF    72,F
02D4:  BTFSS  03.0
02D5:  GOTO   2DA
02D6:  BSF    03.5
02D7:  BSF    08.0
02D8:  GOTO   2DF
02D9:  BCF    03.5
02DA:  BSF    03.5
02DB:  BCF    08.0
02DC:  BCF    03.5
02DD:  BCF    08.0
02DE:  BSF    03.5
.................... 		// dá um pulso em scl  
.................... 		seta_scl;  
02DF:  BSF    08.1
.................... 		conta--;  
02E0:  DECF   73,F
.................... 		apaga_scl;  
02E1:  BCF    08.1
02E2:  BCF    03.5
02E3:  BCF    08.1
.................... 	}  
02E4:  GOTO   2CF
.................... 	// ativa sda  
.................... 	seta_sda;  
02E5:  BSF    03.5
02E6:  BSF    08.0
.................... }  
02E7:  BCF    03.5
02E8:  RETLW  00
.................... unsigned char I2C_le_byte()  
.................... // recebe um byte pelo barramento I2C  
.................... {  
.................... 	unsigned char bytelido, conta = 8;  
*
0337:  MOVLW  08
0338:  MOVWF  71
.................... 	bytelido = 0;  
0339:  CLRF   70
.................... 	apaga_scl;  
033A:  BSF    03.5
033B:  BCF    08.1
033C:  BCF    03.5
033D:  BCF    08.1
.................... 	seta_sda;  
033E:  BSF    03.5
033F:  BSF    08.0
.................... 	while (conta)  
.................... 	{  
0340:  MOVF   71,F
0341:  BTFSC  03.2
0342:  GOTO   353
.................... 		// ativa scl  
.................... 		seta_scl;  
0343:  BSF    08.1
.................... 		// lê o bit em sda, deslocando em bytelido  
.................... 		shift_left(&bytelido,1,input(sda));  
0344:  BSF    08.0
0345:  BCF    03.5
0346:  BTFSC  08.0
0347:  GOTO   34A
0348:  BCF    03.0
0349:  GOTO   34B
034A:  BSF    03.0
034B:  RLF    70,F
.................... 		conta--;  
034C:  DECF   71,F
.................... 		// desativa scl  
.................... 		apaga_scl;  
034D:  BSF    03.5
034E:  BCF    08.1
034F:  BCF    03.5
0350:  BCF    08.1
.................... 	}  
0351:  BSF    03.5
0352:  GOTO   340
.................... 	return bytelido;  
0353:  MOVF   70,W
0354:  MOVWF  78
.................... }  
....................   
.................... void escreve_eeprom(byte dispositivo, long endereco, byte dado)  
.................... // Escreve um dado em um endereço do dispositivo  
.................... // dispositivo - é o endereço do dispositivo escravo (0 - 7)  
.................... // endereco - é o endereço da memória a ser escrito  
.................... // dado - é a informação a ser armazenada  
.................... {  
.................... /* Funcao antiga retirada do livro  
.................... 	if (dispositivo>7) dispositivo = 7;  
....................    i2c_start();  
....................    i2c_escreve_byte(0xa0 | (dispositivo << 1)); // endereça o dispositivo  
....................    i2c_le_ack();  
....................    i2c_escreve_byte(endereco >> 8);	// parte alta do endereço  
....................    i2c_le_ack();  
....................    i2c_escreve_byte(endereco);	// parte baixa do endereço  
....................    i2c_le_ack();  
....................    i2c_escreve_byte(dado);			// dado a ser escrito  
....................    i2c_le_ack();  
....................    i2c_stop();  
....................    delay_ms(10); // aguarda a programação da memória  
.................... */  
....................    //Funcao atual retirada dos manuais do C CSS  
....................    while(!ext_eeprom_ready());  
*
047C:  MOVF   78,F
047D:  BTFSC  03.2
047E:  GOTO   44F
....................    i2c_start();  
047F:  BSF    03.5
0480:  BSF    08.0
0481:  NOP
0482:  BSF    08.1
0483:  NOP
0484:  BCF    03.5
0485:  BCF    08.0
0486:  BSF    03.5
0487:  BCF    08.0
0488:  NOP
0489:  BCF    03.5
048A:  BCF    08.1
048B:  BSF    03.5
048C:  BCF    08.1
....................    i2c_write(0xa0 | (dispositivo << 1));  
048D:  BCF    03.0
048E:  BCF    03.5
048F:  RLF    65,W
0490:  IORLW  A0
0491:  MOVWF  69
0492:  BSF    03.5
0493:  MOVWF  20
0494:  BCF    03.5
0495:  CALL   416
....................    i2c_write(endereco >> 8);  
0496:  MOVF   67,W
0497:  MOVWF  69
0498:  CLRF   6A
0499:  MOVF   67,W
049A:  BSF    03.5
049B:  MOVWF  20
049C:  BCF    03.5
049D:  CALL   416
....................    i2c_write(endereco);  
049E:  MOVF   66,W
049F:  BSF    03.5
04A0:  MOVWF  20
04A1:  BCF    03.5
04A2:  CALL   416
....................    i2c_write(dado);  
04A3:  MOVF   68,W
04A4:  BSF    03.5
04A5:  MOVWF  20
04A6:  BCF    03.5
04A7:  CALL   416
....................    i2c_stop();  
04A8:  BSF    03.5
04A9:  BCF    08.0
04AA:  NOP
04AB:  BSF    08.1
04AC:  BCF    03.5
04AD:  BTFSC  08.1
04AE:  GOTO   4B1
04AF:  BSF    03.5
04B0:  GOTO   4AC
04B1:  NOP
04B2:  NOP
04B3:  NOP
04B4:  NOP
04B5:  BSF    03.5
04B6:  BSF    08.0
04B7:  NOP
....................    delay_ms(10);  
04B8:  MOVLW  0A
04B9:  MOVWF  70
04BA:  BCF    03.5
04BB:  CALL   075
.................... }  
04BC:  RETLW  00
....................   
.................... byte le_eeprom(byte dispositivo, long int endereco)  
.................... // Lê um dado de um endereço especificado no dispositivo  
.................... // dispositivo - é o endereço do dispositivo escravo (0 - 7)  
.................... // endereco - é o endereço da memória a ser escrito  
.................... {  
....................    byte dado;  
.................... 	if (dispositivo>7) dispositivo = 7;  
*
02FA:  MOVF   6C,W
02FB:  SUBLW  07
02FC:  BTFSC  03.0
02FD:  GOTO   300
02FE:  MOVLW  07
02FF:  MOVWF  6C
....................    i2c_start();  
0300:  BSF    03.5
0301:  BSF    08.0
0302:  NOP
0303:  BSF    08.1
0304:  NOP
0305:  BCF    03.5
0306:  BCF    08.0
0307:  BSF    03.5
0308:  BCF    08.0
0309:  NOP
030A:  BCF    03.5
030B:  BCF    08.1
030C:  BSF    03.5
030D:  BCF    08.1
....................    i2c_escreve_byte(0xa0 | (dispositivo << 1)); // endereça o dispositivo  
030E:  BCF    03.0
030F:  BCF    03.5
0310:  RLF    6C,W
0311:  IORLW  A0
0312:  MOVWF  70
0313:  MOVWF  72
0314:  CALL   2C9
....................    i2c_le_ack();  
0315:  CALL   2E9
....................    i2c_escreve_byte((endereco >> 8));	// envia a parte alta do endereço  
0316:  MOVF   6E,W
0317:  MOVWF  70
0318:  CLRF   71
0319:  MOVF   6E,W
031A:  MOVWF  72
031B:  CALL   2C9
....................    i2c_le_ack();  
031C:  CALL   2E9
....................    i2c_escreve_byte(endereco);	// envia a parte baixa do endereço  
031D:  MOVF   6D,W
031E:  MOVWF  72
031F:  CALL   2C9
....................    i2c_le_ack();  
0320:  CALL   2E9
....................    i2c_start();  
0321:  BSF    03.5
0322:  BSF    08.0
0323:  NOP
0324:  BSF    08.1
0325:  NOP
0326:  BCF    03.5
0327:  BCF    08.0
0328:  BSF    03.5
0329:  BCF    08.0
032A:  NOP
032B:  BCF    03.5
032C:  BCF    08.1
032D:  BSF    03.5
032E:  BCF    08.1
.................... 	//envia comando de leitura  
....................    i2c_escreve_byte(0xa1 | (dispositivo << 1));  
032F:  BCF    03.0
0330:  BCF    03.5
0331:  RLF    6C,W
0332:  IORLW  A1
0333:  MOVWF  70
0334:  MOVWF  72
0335:  CALL   2C9
....................    i2c_le_ack();  
0336:  CALL   2E9
....................    dado = i2c_le_byte();	// lê o dado  
*
0355:  MOVF   78,W
0356:  BCF    03.5
0357:  MOVWF  6F
.................... 	i2c_nack();  
....................    i2c_stop();  
*
035E:  BSF    03.5
035F:  BCF    08.0
0360:  NOP
0361:  BSF    08.1
0362:  BCF    03.5
0363:  BTFSC  08.1
0364:  GOTO   367
0365:  BSF    03.5
0366:  GOTO   362
0367:  NOP
0368:  NOP
0369:  NOP
036A:  NOP
036B:  BSF    03.5
036C:  BSF    08.0
036D:  NOP
....................    return dado;  
036E:  BCF    03.5
036F:  MOVF   6F,W
0370:  MOVWF  78
.................... }  
0371:  RETLW  00
....................   
.................... // Lê um dado de 16 bits um endereço especificado no dispositivo  
.................... // dispositivo - é o endereço do dispositivo escravo (0 - 7)  
.................... // endereco - é o endereço da memória a ser escrito  
....................   
.................... long int le_eeprom_16(byte dispositivo,long endereco){  
....................   int8 pLow, pHigh;  
....................   long resultado;  
....................   pHigh = le_eeprom(dispositivo,endereco);  
*
0879:  MOVF   65,W
087A:  MOVWF  6C
087B:  MOVF   67,W
087C:  MOVWF  6E
087D:  MOVF   66,W
087E:  MOVWF  6D
087F:  BCF    0A.3
0880:  CALL   2FA
0881:  BSF    0A.3
0882:  MOVF   78,W
0883:  MOVWF  69
....................   endereco++;  
0884:  INCF   66,F
0885:  BTFSC  03.2
0886:  INCF   67,F
....................   pLow =  le_eeprom(dispositivo,endereco);  
0887:  MOVF   65,W
0888:  MOVWF  6C
0889:  MOVF   67,W
088A:  MOVWF  6E
088B:  MOVF   66,W
088C:  MOVWF  6D
088D:  BCF    0A.3
088E:  CALL   2FA
088F:  BSF    0A.3
0890:  MOVF   78,W
0891:  MOVWF  68
....................   resultado=(pHigh<<8);  
0892:  MOVF   69,W
0893:  MOVWF  6B
0894:  CLRF   6A
....................   resultado+=pLow;  
0895:  MOVF   68,W
0896:  ADDWF  6A,F
0897:  BTFSC  03.0
0898:  INCF   6B,F
....................   return resultado;  
0899:  MOVF   6A,W
089A:  MOVWF  78
089B:  MOVF   6B,W
089C:  MOVWF  79
.................... }  
....................   
.................... // Escreve um dado em um endereço do dispositivo  
.................... // dispositivo - é o endereço do dispositivo escravo (0 - 7)  
.................... // endereco - é o endereço da memória a ser escrito  
.................... // dado - é a informação a ser armazenada  
....................   
.................... void escreve_eeprom_16(byte dispositivo,long endereco, long dado){  
....................   int8 pLow, pHigh;  
....................   pLow = dado;  
*
1160:  MOVF   5A,W
1161:  MOVWF  5C
....................   pHigh = (dado >> 8);  
1162:  MOVF   5B,W
1163:  MOVWF  5D
....................   escreve_eeprom(dispositivo,endereco,pHigh);  
1164:  MOVF   57,W
1165:  MOVWF  65
1166:  MOVF   59,W
1167:  MOVWF  67
1168:  MOVF   58,W
1169:  MOVWF  66
116A:  MOVF   5D,W
116B:  MOVWF  68
116C:  BCF    0A.4
116D:  CALL   44F
116E:  BSF    0A.4
....................   delay_ms(12);  
116F:  MOVLW  0C
1170:  MOVWF  70
1171:  BCF    0A.4
1172:  CALL   075
1173:  BSF    0A.4
....................   endereco++;  
1174:  INCF   58,F
1175:  BTFSC  03.2
1176:  INCF   59,F
....................   escreve_eeprom(dispositivo,endereco,pLow);  
1177:  MOVF   57,W
1178:  MOVWF  65
1179:  MOVF   59,W
117A:  MOVWF  67
117B:  MOVF   58,W
117C:  MOVWF  66
117D:  MOVF   5C,W
117E:  MOVWF  68
117F:  BCF    0A.4
1180:  CALL   44F
1181:  BSF    0A.4
....................   delay_ms(12);  
1182:  MOVLW  0C
1183:  MOVWF  70
1184:  BCF    0A.4
1185:  CALL   075
1186:  BSF    0A.4
.................... }  
1187:  BSF    0A.3
1188:  BSF    0A.4
1189:  GOTO   4EF (RETURN)
....................   
....................  
.................... //Arquivo com biblioteca de funcoes do RTC  
.................... #include <PCF_RTC.c> 
....................  // PCF8583.C  
....................   
.................... /*  
.................... #ifndef sda  
....................    #define sda          pin_d0  
....................    #define scl          pin_d1  
.................... #endif  
.................... */  
....................   
....................   
.................... #ifndef PCF8583_WRITE_ADDRESS  
....................    #define PCF8583_WRITE_ADDRESS   0xA2  
....................    #define PCF8583_READ_ADDRESS    0xA3  
.................... #endif  
....................   
.................... // Register addresses  
.................... #define PCF8583_CTRL_STATUS_REG    0x00  
.................... #define PCF8583_100S_REG           0x01  
.................... #define PCF8583_SECONDS_REG        0x02  
.................... #define PCF8583_MINUTES_REG        0x03  
.................... #define PCF8583_HOURS_REG          0x04  
.................... #define PCF8583_DATE_REG           0x05  
.................... #define PCF8583_MONTHS_REG         0x06  
.................... #define PCF8583_TIMER_REG          0x07  
....................   
.................... /*  
.................... #define PCF8583_ALARM_CONTROL_REG  0x08  
.................... #define PCF8583_ALARM_100S_REG     0x09  
.................... #define PCF8583_ALARM_SECS_REG     0x0A  
.................... #define PCF8583_ALARM_MINS_REG     0x0B  
.................... #define PCF8583_ALARM_HOURS_REG    0x0C  
.................... #define PCF8583_ALARM_DATE_REG     0x0D  
.................... #define PCF8583_ALARM_MONTHS_REG   0x0E  
.................... #define PCF8583_ALARM_TIMER_REG    0x0F  
.................... */  
....................   
.................... // Use the first NVRAM address for the year byte.  
.................... #define PCF8583_YEAR_REG           0x10  
....................   
....................   
.................... // Commands for the Control/Status register.  
.................... #define PCF8583_START_COUNTING     0x00  
.................... #define PCF8583_STOP_COUNTING      0x80  
....................   
.................... char const weekday_names[7][4] =  
.................... {  
.................... {"Dom"},  
.................... {"Seg"},  
.................... {"Ter"},  
.................... {"Qua"},  
.................... {"Qui"},  
.................... {"Sex"},  
.................... {"Sab"}  
.................... };  
....................   
.................... // This structure defines the user's date and time data.  
.................... // The values are stored as unsigned integers.  The user  
.................... // should declare a structure of this type in the application  
.................... // program. Then the address of the structure should be  
.................... // passed to the PCF8583 read/write functions in this  
.................... // driver, whenever you want to talk to the chip.  
.................... typedef struct  
.................... {  
....................    int8 seconds;    // 0 to 59  
....................    int8 minutes;    // 0 to 59  
....................    int8 hours;      // 0 to 23  (24-hour time)  
....................    int8 day;        // 1 to 31  
....................    int8 month;      // 1 to 12  
....................    int8 year;       // 00 to 99  
....................    int8 weekday;    // 0 = Sunday, 1 = Monday, etc.  
.................... }date_time_t;  
....................   
....................   
.................... //----------------------------------------------  
.................... void PCF8583_write_byte(int8 address, int8 data)  
.................... {  
.................... //disable_interrupts(GLOBAL);  
.................... i2c_start();  
*
0782:  BSF    03.5
0783:  BSF    08.0
0784:  NOP
0785:  BSF    08.1
0786:  NOP
0787:  BCF    03.5
0788:  BCF    08.0
0789:  BSF    03.5
078A:  BCF    08.0
078B:  NOP
078C:  BCF    03.5
078D:  BCF    08.1
078E:  BSF    03.5
078F:  BCF    08.1
.................... i2c_write(PCF8583_WRITE_ADDRESS);  
0790:  MOVLW  A2
0791:  MOVWF  20
0792:  BCF    03.5
0793:  CALL   416
.................... i2c_write(address);  
0794:  MOVF   7D,W
0795:  BSF    03.5
0796:  MOVWF  20
0797:  BCF    03.5
0798:  CALL   416
.................... i2c_write(data);  
0799:  MOVF   7E,W
079A:  BSF    03.5
079B:  MOVWF  20
079C:  BCF    03.5
079D:  CALL   416
.................... i2c_stop();  
079E:  BSF    03.5
079F:  BCF    08.0
07A0:  NOP
07A1:  BSF    08.1
07A2:  BCF    03.5
07A3:  BTFSC  08.1
07A4:  GOTO   7A7
07A5:  BSF    03.5
07A6:  GOTO   7A2
07A7:  NOP
07A8:  NOP
07A9:  NOP
07AA:  NOP
07AB:  BSF    03.5
07AC:  BSF    08.0
07AD:  NOP
.................... //enable_interrupts(GLOBAL);  
.................... }  
07AE:  BCF    03.5
07AF:  RETLW  00
....................   
.................... //----------------------------------------------  
.................... int8 PCF8583_read_byte(int8 address)  
.................... {  
.................... int8 retval;  
....................   
.................... //disable_interrupts(GLOBAL);  
.................... i2c_start();  
*
0AFB:  BSF    03.5
0AFC:  BSF    08.0
0AFD:  NOP
0AFE:  BSF    08.1
0AFF:  NOP
0B00:  BCF    03.5
0B01:  BCF    08.0
0B02:  BSF    03.5
0B03:  BCF    08.0
0B04:  NOP
0B05:  BCF    03.5
0B06:  BCF    08.1
0B07:  BSF    03.5
0B08:  BCF    08.1
.................... i2c_write(PCF8583_WRITE_ADDRESS);  
0B09:  MOVLW  A2
0B0A:  MOVWF  20
0B0B:  BCF    0A.3
0B0C:  BCF    03.5
0B0D:  CALL   416
0B0E:  BSF    0A.3
.................... i2c_write(address);  
0B0F:  MOVF   7C,W
0B10:  BSF    03.5
0B11:  MOVWF  20
0B12:  BCF    0A.3
0B13:  BCF    03.5
0B14:  CALL   416
0B15:  BSF    0A.3
.................... i2c_start();  
0B16:  BSF    03.5
0B17:  BSF    08.0
0B18:  NOP
0B19:  BSF    08.1
0B1A:  NOP
0B1B:  BCF    03.5
0B1C:  BCF    08.0
0B1D:  BSF    03.5
0B1E:  BCF    08.0
0B1F:  NOP
0B20:  BCF    03.5
0B21:  BCF    08.1
0B22:  BSF    03.5
0B23:  BCF    08.1
.................... i2c_write(PCF8583_READ_ADDRESS);  
0B24:  MOVLW  A3
0B25:  MOVWF  20
0B26:  BCF    0A.3
0B27:  BCF    03.5
0B28:  CALL   416
0B29:  BSF    0A.3
.................... retval = i2c_read(0);  
0B2A:  CLRF   77
0B2B:  BCF    0A.3
0B2C:  CALL   739
0B2D:  BSF    0A.3
0B2E:  MOVF   78,W
0B2F:  MOVWF  7D
.................... i2c_stop();  
0B30:  BSF    03.5
0B31:  BCF    08.0
0B32:  NOP
0B33:  BSF    08.1
0B34:  BCF    03.5
0B35:  BTFSC  08.1
0B36:  GOTO   339
0B37:  BSF    03.5
0B38:  GOTO   334
0B39:  NOP
0B3A:  NOP
0B3B:  NOP
0B3C:  NOP
0B3D:  BSF    03.5
0B3E:  BSF    08.0
0B3F:  NOP
.................... //enable_interrupts(GLOBAL);  
.................... return(retval);  
0B40:  MOVF   7D,W
0B41:  MOVWF  78
.................... }  
....................   
....................   
.................... void PCF8583_init(void)  
.................... {  
.................... PCF8583_write_byte(PCF8583_CTRL_STATUS_REG,  
....................                               PCF8583_START_COUNTING);  
.................... }  
....................   
.................... //----------------------------------------------  
.................... // This function converts an 8 bit binary value  
.................... // to an 8 bit BCD value.  
.................... // The input range must be from 0 to 99.  
....................   
.................... int8 bin2bcd(int8 value)  
.................... {  
.................... char retval;  
....................   
.................... retval = 0;  
*
0FDC:  CLRF   7E
....................   
.................... while(1)  
....................   {  
....................    // Get the tens digit by doing multiple subtraction  
....................    // of 10 from the binary value.  
....................    if(value >= 10)  
0FDD:  MOVF   7D,W
0FDE:  SUBLW  09
0FDF:  BTFSC  03.0
0FE0:  GOTO   7E6
....................      {  
....................       value -= 10;  
0FE1:  MOVLW  0A
0FE2:  SUBWF  7D,F
....................       retval += 0x10;  
0FE3:  MOVLW  10
0FE4:  ADDWF  7E,F
....................      }  
....................    else // Get the ones digit by adding the remainder.  
0FE5:  GOTO   7E9
....................      {  
....................       retval += value;  
0FE6:  MOVF   7D,W
0FE7:  ADDWF  7E,F
....................       break;  
0FE8:  GOTO   7EA
....................      }  
....................    }  
0FE9:  GOTO   7DD
....................   
.................... return(retval);  
0FEA:  MOVF   7E,W
0FEB:  MOVWF  78
.................... }  
0FEC:  RETLW  00
....................   
.................... //----------------------------------------------  
.................... // This function converts an 8 bit BCD value to  
.................... // an 8 bit binary value.  
.................... // The input range must be from 00 to 99.  
....................   
.................... char bcd2bin(char bcd_value)  
.................... {  
.................... char temp;  
....................   
.................... temp = bcd_value;  
*
076D:  MOVF   7E,W
076E:  BSF    03.5
076F:  MOVWF  20
....................   
.................... // Shifting the upper digit right by 1 is  
.................... // the same as multiplying it by 8.  
.................... temp >>= 1;  
0770:  BCF    03.0
0771:  RRF    20,F
....................   
.................... // Isolate the bits for the upper digit.  
.................... temp &= 0x78;  
0772:  MOVLW  78
0773:  ANDWF  20,F
....................   
.................... // Now return: (Tens * 8) + (Tens * 2) + Ones  
.................... return(temp + (temp >> 2) + (bcd_value & 0x0f));  
0774:  RRF    20,W
0775:  MOVWF  77
0776:  RRF    77,F
0777:  MOVLW  3F
0778:  ANDWF  77,F
0779:  MOVF   77,W
077A:  ADDWF  20,W
077B:  MOVWF  21
077C:  MOVF   7E,W
077D:  ANDLW  0F
077E:  ADDWF  21,W
077F:  MOVWF  78
....................   
.................... }  
0780:  BCF    03.5
0781:  RETLW  00
....................   
.................... //----------------------------------------------  
.................... void PCF8583_set_datetime(date_time_t *dt)  
.................... {  
.................... int8 bcd_sec;  
.................... int8 bcd_min;  
.................... int8 bcd_hrs;  
.................... int8 bcd_day;  
.................... int8 bcd_mon;  
....................   
.................... // Convert the input date/time into BCD values  
.................... // that are formatted for the PCF8583 registers.  
.................... bcd_sec = bin2bcd(dt->seconds);  
*
127C:  MOVF   6F,W
127D:  MOVWF  04
127E:  MOVF   00,W
127F:  MOVWF  7C
1280:  MOVWF  7D
1281:  BCF    0A.4
1282:  BSF    0A.3
1283:  CALL   7DC
1284:  BSF    0A.4
1285:  BCF    0A.3
1286:  MOVF   78,W
1287:  MOVWF  70
.................... bcd_min = bin2bcd(dt->minutes);  
1288:  MOVLW  01
1289:  ADDWF  6F,W
128A:  MOVWF  04
128B:  MOVF   00,W
128C:  MOVWF  7C
128D:  MOVWF  7D
128E:  BCF    0A.4
128F:  BSF    0A.3
1290:  CALL   7DC
1291:  BSF    0A.4
1292:  BCF    0A.3
1293:  MOVF   78,W
1294:  MOVWF  71
.................... bcd_hrs = bin2bcd(dt->hours);  
1295:  MOVLW  02
1296:  ADDWF  6F,W
1297:  MOVWF  04
1298:  MOVF   00,W
1299:  MOVWF  7C
129A:  MOVWF  7D
129B:  BCF    0A.4
129C:  BSF    0A.3
129D:  CALL   7DC
129E:  BSF    0A.4
129F:  BCF    0A.3
12A0:  MOVF   78,W
12A1:  MOVWF  72
.................... bcd_day = bin2bcd(dt->day) | (dt->year << 6);  
12A2:  MOVLW  03
12A3:  ADDWF  6F,W
12A4:  MOVWF  04
12A5:  MOVF   00,W
12A6:  MOVWF  7C
12A7:  MOVWF  7D
12A8:  BCF    0A.4
12A9:  BSF    0A.3
12AA:  CALL   7DC
12AB:  BSF    0A.4
12AC:  BCF    0A.3
12AD:  MOVLW  05
12AE:  ADDWF  6F,W
12AF:  MOVWF  04
12B0:  SWAPF  00,W
12B1:  MOVWF  77
12B2:  RLF    77,F
12B3:  RLF    77,F
12B4:  MOVLW  C0
12B5:  ANDWF  77,F
12B6:  MOVF   77,W
12B7:  IORWF  78,W
12B8:  MOVWF  73
.................... bcd_mon = bin2bcd(dt->month) | (dt->weekday << 5);  
12B9:  MOVLW  04
12BA:  ADDWF  6F,W
12BB:  MOVWF  04
12BC:  MOVF   00,W
12BD:  MOVWF  7C
12BE:  MOVWF  7D
12BF:  BCF    0A.4
12C0:  BSF    0A.3
12C1:  CALL   7DC
12C2:  BSF    0A.4
12C3:  BCF    0A.3
12C4:  MOVLW  06
12C5:  ADDWF  6F,W
12C6:  MOVWF  04
12C7:  SWAPF  00,W
12C8:  MOVWF  77
12C9:  RLF    77,F
12CA:  MOVLW  E0
12CB:  ANDWF  77,F
12CC:  MOVF   77,W
12CD:  IORWF  78,W
12CE:  MOVWF  74
....................   
.................... // Stop the RTC from counting, before we write to  
.................... // the date and time registers.  
.................... PCF8583_write_byte(PCF8583_CTRL_STATUS_REG,  
....................                               PCF8583_STOP_COUNTING);  
12CF:  CLRF   7D
12D0:  MOVLW  80
12D1:  MOVWF  7E
12D2:  BCF    0A.4
12D3:  CALL   782
12D4:  BSF    0A.4
....................   
.................... // Write to the date and time registers.  Disable interrupts  
.................... // so they can't disrupt the i2c operations.  
.................... disable_interrupts(GLOBAL);  
12D5:  BCF    0B.6
12D6:  BCF    0B.7
12D7:  BTFSC  0B.7
12D8:  GOTO   2D6
.................... i2c_start();  
12D9:  BSF    03.5
12DA:  BSF    08.0
12DB:  NOP
12DC:  BSF    08.1
12DD:  NOP
12DE:  BCF    03.5
12DF:  BCF    08.0
12E0:  BSF    03.5
12E1:  BCF    08.0
12E2:  NOP
12E3:  BCF    03.5
12E4:  BCF    08.1
12E5:  BSF    03.5
12E6:  BCF    08.1
.................... i2c_write(PCF8583_WRITE_ADDRESS);  
12E7:  MOVLW  A2
12E8:  MOVWF  20
12E9:  BCF    0A.4
12EA:  BCF    03.5
12EB:  CALL   416
12EC:  BSF    0A.4
.................... i2c_write(PCF8583_100S_REG);   // Start at 100's reg.  
12ED:  MOVLW  01
12EE:  BSF    03.5
12EF:  MOVWF  20
12F0:  BCF    0A.4
12F1:  BCF    03.5
12F2:  CALL   416
12F3:  BSF    0A.4
.................... i2c_write(0x00);               // Set 100's reg = 0  
12F4:  BSF    03.5
12F5:  CLRF   20
12F6:  BCF    0A.4
12F7:  BCF    03.5
12F8:  CALL   416
12F9:  BSF    0A.4
.................... i2c_write(bcd_sec);  
12FA:  MOVF   70,W
12FB:  BSF    03.5
12FC:  MOVWF  20
12FD:  BCF    0A.4
12FE:  BCF    03.5
12FF:  CALL   416
1300:  BSF    0A.4
.................... i2c_write(bcd_min);  
1301:  MOVF   71,W
1302:  BSF    03.5
1303:  MOVWF  20
1304:  BCF    0A.4
1305:  BCF    03.5
1306:  CALL   416
1307:  BSF    0A.4
.................... i2c_write(bcd_hrs);  
1308:  MOVF   72,W
1309:  BSF    03.5
130A:  MOVWF  20
130B:  BCF    0A.4
130C:  BCF    03.5
130D:  CALL   416
130E:  BSF    0A.4
.................... i2c_write(bcd_day);  
130F:  MOVF   73,W
1310:  BSF    03.5
1311:  MOVWF  20
1312:  BCF    0A.4
1313:  BCF    03.5
1314:  CALL   416
1315:  BSF    0A.4
.................... i2c_write(bcd_mon);  
1316:  MOVF   74,W
1317:  BSF    03.5
1318:  MOVWF  20
1319:  BCF    0A.4
131A:  BCF    03.5
131B:  CALL   416
131C:  BSF    0A.4
.................... i2c_stop();  
131D:  BSF    03.5
131E:  BCF    08.0
131F:  NOP
1320:  BSF    08.1
1321:  BCF    03.5
1322:  BTFSC  08.1
1323:  GOTO   326
1324:  BSF    03.5
1325:  GOTO   321
1326:  NOP
1327:  NOP
1328:  NOP
1329:  NOP
132A:  BSF    03.5
132B:  BSF    08.0
132C:  NOP
.................... //enable_interrupts(GLOBAL);  
....................   
.................... // Write the year byte to the first NVRAM location.  
.................... // Leave it in binary format.  
.................... PCF8583_write_byte(PCF8583_YEAR_REG, dt->year);  
132D:  MOVLW  05
132E:  BCF    03.5
132F:  ADDWF  6F,W
1330:  MOVWF  04
1331:  MOVF   00,W
1332:  MOVWF  7C
1333:  MOVLW  10
1334:  MOVWF  7D
1335:  MOVF   7C,W
1336:  MOVWF  7E
1337:  BCF    0A.4
1338:  CALL   782
1339:  BSF    0A.4
....................   
.................... // Now allow the PCF8583 to start counting again.  
.................... PCF8583_write_byte(PCF8583_CTRL_STATUS_REG,  
....................                               PCF8583_START_COUNTING);  
133A:  CLRF   7D
133B:  CLRF   7E
133C:  BCF    0A.4
133D:  CALL   782
133E:  BSF    0A.4
.................... }  
....................   
.................... //----------------------------------------------  
.................... // Read the Date and Time from the hardware registers  
.................... // in the PCF8583.   We don't have to disable counting  
.................... // during read operations, because according to the data  
.................... // sheet, if any of the lower registers (1 to 7) is read,  
.................... // all of them are loaded into "capture" registers.  
.................... // All further reading within that cycle is done from  
.................... // those registers.  
....................   
.................... void PCF8583_read_datetime(date_time_t *dt)  
.................... {  
.................... int8 year_bits;  
.................... int8 year;  
....................   
.................... int8 bcd_sec;  
.................... int8 bcd_min;  
.................... int8 bcd_hrs;  
.................... int8 bcd_day;  
.................... int8 bcd_mon;  
....................   
.................... // Disable interrupts so the i2c process is not disrupted.  
.................... //disable_interrupts(GLOBAL);  
....................   
.................... // Read the date/time registers inside the PCF8583.  
.................... i2c_start();  
*
0A46:  BSF    03.5
0A47:  BSF    08.0
0A48:  NOP
0A49:  BSF    08.1
0A4A:  NOP
0A4B:  BCF    03.5
0A4C:  BCF    08.0
0A4D:  BSF    03.5
0A4E:  BCF    08.0
0A4F:  NOP
0A50:  BCF    03.5
0A51:  BCF    08.1
0A52:  BSF    03.5
0A53:  BCF    08.1
.................... i2c_write(PCF8583_WRITE_ADDRESS);  
0A54:  MOVLW  A2
0A55:  MOVWF  20
0A56:  BCF    0A.3
0A57:  BCF    03.5
0A58:  CALL   416
0A59:  BSF    0A.3
.................... i2c_write(PCF8583_SECONDS_REG);   // Start at seconds reg.  
0A5A:  MOVLW  02
0A5B:  BSF    03.5
0A5C:  MOVWF  20
0A5D:  BCF    0A.3
0A5E:  BCF    03.5
0A5F:  CALL   416
0A60:  BSF    0A.3
.................... i2c_start();  
0A61:  BSF    03.5
0A62:  BSF    08.0
0A63:  NOP
0A64:  BSF    08.1
0A65:  NOP
0A66:  BCF    03.5
0A67:  BCF    08.0
0A68:  BSF    03.5
0A69:  BCF    08.0
0A6A:  NOP
0A6B:  BCF    03.5
0A6C:  BCF    08.1
0A6D:  BSF    03.5
0A6E:  BCF    08.1
.................... i2c_write(PCF8583_READ_ADDRESS);  
0A6F:  MOVLW  A3
0A70:  MOVWF  20
0A71:  BCF    0A.3
0A72:  BCF    03.5
0A73:  CALL   416
0A74:  BSF    0A.3
....................   
.................... bcd_sec = i2c_read();  
0A75:  MOVLW  01
0A76:  MOVWF  77
0A77:  BCF    0A.3
0A78:  CALL   739
0A79:  BSF    0A.3
0A7A:  MOVF   78,W
0A7B:  MOVWF  72
.................... bcd_min = i2c_read();  
0A7C:  MOVLW  01
0A7D:  MOVWF  77
0A7E:  BCF    0A.3
0A7F:  CALL   739
0A80:  BSF    0A.3
0A81:  MOVF   78,W
0A82:  MOVWF  73
.................... bcd_hrs = i2c_read();  
0A83:  MOVLW  01
0A84:  MOVWF  77
0A85:  BCF    0A.3
0A86:  CALL   739
0A87:  BSF    0A.3
0A88:  MOVF   78,W
0A89:  MOVWF  74
.................... bcd_day = i2c_read();  
0A8A:  MOVLW  01
0A8B:  MOVWF  77
0A8C:  BCF    0A.3
0A8D:  CALL   739
0A8E:  BSF    0A.3
0A8F:  MOVF   78,W
0A90:  MOVWF  75
.................... bcd_mon = i2c_read(0);  
0A91:  CLRF   77
0A92:  BCF    0A.3
0A93:  CALL   739
0A94:  BSF    0A.3
0A95:  MOVF   78,W
0A96:  MOVWF  76
.................... i2c_stop();  
0A97:  BSF    03.5
0A98:  BCF    08.0
0A99:  NOP
0A9A:  BSF    08.1
0A9B:  BCF    03.5
0A9C:  BTFSC  08.1
0A9D:  GOTO   2A0
0A9E:  BSF    03.5
0A9F:  GOTO   29B
0AA0:  NOP
0AA1:  NOP
0AA2:  NOP
0AA3:  NOP
0AA4:  BSF    03.5
0AA5:  BSF    08.0
0AA6:  NOP
....................   
.................... //enable_interrupts(GLOBAL);  
....................   
.................... // Convert the date/time values from BCD to  
.................... // unsigned 8-bit integers.  Unpack the bits  
.................... // in the PCF8583 registers where required.  
.................... dt->seconds = bcd2bin(bcd_sec);  
0AA7:  BCF    03.5
0AA8:  MOVF   6F,W
0AA9:  MOVWF  7C
0AAA:  MOVF   72,W
0AAB:  MOVWF  7E
0AAC:  BCF    0A.3
0AAD:  CALL   76D
0AAE:  BSF    0A.3
0AAF:  MOVF   7C,W
0AB0:  MOVWF  04
0AB1:  MOVF   78,W
0AB2:  MOVWF  00
.................... dt->minutes = bcd2bin(bcd_min);  
0AB3:  MOVLW  01
0AB4:  ADDWF  6F,W
0AB5:  MOVWF  7C
0AB6:  MOVF   73,W
0AB7:  MOVWF  7E
0AB8:  BCF    0A.3
0AB9:  CALL   76D
0ABA:  BSF    0A.3
0ABB:  MOVF   7C,W
0ABC:  MOVWF  04
0ABD:  MOVF   78,W
0ABE:  MOVWF  00
.................... dt->hours   = bcd2bin(bcd_hrs & 0x3F);  
0ABF:  MOVLW  02
0AC0:  ADDWF  6F,W
0AC1:  MOVWF  7C
0AC2:  MOVF   74,W
0AC3:  ANDLW  3F
0AC4:  MOVWF  7D
0AC5:  MOVWF  7E
0AC6:  BCF    0A.3
0AC7:  CALL   76D
0AC8:  BSF    0A.3
0AC9:  MOVF   7C,W
0ACA:  MOVWF  04
0ACB:  MOVF   78,W
0ACC:  MOVWF  00
.................... dt->day     = bcd2bin(bcd_day & 0x3F);  
0ACD:  MOVLW  03
0ACE:  ADDWF  6F,W
0ACF:  MOVWF  7C
0AD0:  MOVF   75,W
0AD1:  ANDLW  3F
0AD2:  MOVWF  7D
0AD3:  MOVWF  7E
0AD4:  BCF    0A.3
0AD5:  CALL   76D
0AD6:  BSF    0A.3
0AD7:  MOVF   7C,W
0AD8:  MOVWF  04
0AD9:  MOVF   78,W
0ADA:  MOVWF  00
.................... dt->month   = bcd2bin(bcd_mon & 0x1F);  
0ADB:  MOVLW  04
0ADC:  ADDWF  6F,W
0ADD:  MOVWF  7C
0ADE:  MOVF   76,W
0ADF:  ANDLW  1F
0AE0:  MOVWF  7D
0AE1:  MOVWF  7E
0AE2:  BCF    0A.3
0AE3:  CALL   76D
0AE4:  BSF    0A.3
0AE5:  MOVF   7C,W
0AE6:  MOVWF  04
0AE7:  MOVF   78,W
0AE8:  MOVWF  00
.................... dt->weekday = bcd_mon >> 5;  
0AE9:  MOVLW  06
0AEA:  ADDWF  6F,W
0AEB:  MOVWF  04
0AEC:  SWAPF  76,W
0AED:  MOVWF  77
0AEE:  RRF    77,F
0AEF:  MOVLW  07
0AF0:  ANDWF  77,F
0AF1:  MOVF   77,W
0AF2:  MOVWF  00
.................... year_bits   = bcd_day >> 6;  
0AF3:  SWAPF  75,W
0AF4:  MOVWF  70
0AF5:  RRF    70,F
0AF6:  RRF    70,F
0AF7:  MOVLW  03
0AF8:  ANDWF  70,F
....................   
.................... // Read the year byte from NVRAM.  
.................... // This is an added feature of this driver.  
.................... year = PCF8583_read_byte(PCF8583_YEAR_REG);  
0AF9:  MOVLW  10
0AFA:  MOVWF  7C
*
0B42:  MOVF   78,W
0B43:  MOVWF  71
....................   
.................... // Check if the two "year bits" were incremented by  
.................... // the PCF8583.  If so, increment the 8-bit year  
.................... // byte (read from NVRAM) by the same amount.  
.................... while(year_bits != (year & 3))  
....................       year++;  
0B44:  MOVF   71,W
0B45:  ANDLW  03
0B46:  SUBWF  70,W
0B47:  BTFSC  03.2
0B48:  GOTO   34B
0B49:  INCF   71,F
0B4A:  GOTO   344
....................   
.................... dt->year = year;  
0B4B:  MOVLW  05
0B4C:  BCF    03.5
0B4D:  ADDWF  6F,W
0B4E:  MOVWF  04
0B4F:  MOVF   71,W
0B50:  MOVWF  00
....................   
.................... // Now update the year byte in the NVRAM  
.................... // inside the PCF8583.  
.................... PCF8583_write_byte(PCF8583_YEAR_REG, year);  
0B51:  MOVLW  10
0B52:  MOVWF  7D
0B53:  MOVF   71,W
0B54:  MOVWF  7E
0B55:  BCF    0A.3
0B56:  CALL   782
0B57:  BSF    0A.3
....................   
.................... }  
0B58:  RETLW  00
....................  
.................... //Arquivo com biblioteca de funcoes matematicas especiais  
.................... #include <math_mod.h> 
....................  ////////////////////////////////////////////////////////////////////////////  
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////  
.................... //// This source code may only be used by licensed users of the CCS C   ////  
.................... //// compiler.  This source code may only be distributed to other       ////  
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////  
.................... //// or distribution is permitted without written permission.           ////  
.................... //// Derivative programs created using this software in object code     ////  
.................... //// form are not restricted in any way.                                ////  
.................... ////////////////////////////////////////////////////////////////////////////  
.................... ////                                                                    ////  
.................... //// History:                                                           ////  
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////  
.................... ////                 The code now is small, much faster,                ////  
.................... ////                 and more accurate.                                 ////  
.................... ////                                                                    ////  
.................... ////////////////////////////////////////////////////////////////////////////  
....................   
.................... #ifndef MATH_H  
.................... #define MATH_H  
....................   
....................   
....................   
.................... //////////////////// Exponential and logarithmic functions ////////////////////  
....................   
....................   
.................... /************************************************************/  
....................   
.................... float const pl[4] = {0.45145214, -9.0558803, 26.940971, -19.860189};  
.................... float const ql[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943};  
....................   
.................... #define LN2 0.6931471806  
....................   
.................... ////////////////////////////////////////////////////////////////////////////  
.................... //	float log(float x)  
.................... ////////////////////////////////////////////////////////////////////////////  
.................... // Description : returns the the natural log of x  
.................... // Date : N/A  
.................... //  
.................... float log(float x)  
.................... {  
....................    float y, res, r, y2;  
....................    signed n;  
....................    #ifdef _ERRNO  
....................    if(x <0)  
....................    {  
....................       errno=EDOM;  
....................    }  
....................    if(x ==0)  
....................    {  
....................       errno=ERANGE;  
....................       return(0);  
....................    }  
....................    #endif  
....................    y = x;  
....................   
....................    if (y != 1.0)  
....................    {  
....................       *(&y) = 0x7E;  
....................   
....................       y = (y - 1.0)/(y + 1.0);  
....................   
....................       y2=y*y;  
....................   
....................       res = pl[0]*y2 + pl[1];  
....................       res = res*y2 + pl[2];  
....................       res = res*y2 + pl[3];  
....................   
....................       r = ql[0]*y2 + ql[1];  
....................       r = r*y2 + ql[2];  
....................       r = r*y2 + ql[3];  
....................   
....................       res = y*res/r;  
....................   
....................       n = *(&x) - 0x7E;  
....................   
....................       if (n<0)  
....................          r = -(float)-n;  
....................       else  
....................          r = (float)n;  
....................   
....................       res += r*LN2;  
....................    }  
....................   
....................    else  
....................       res = 0.0;  
....................   
....................    return(res);  
.................... }  
....................   
....................   
.................... #define LN10 2.30258509  
....................   
.................... ////////////////////////////////////////////////////////////////////////////  
.................... //	float log10(float x)  
.................... ////////////////////////////////////////////////////////////////////////////  
.................... // Description : returns the the log base 10 of x  
.................... // Date : N/A  
.................... //  
.................... float log10(float x)  
.................... {  
....................    float r;  
....................   
....................    r = log(x);  
....................    r = r/LN10;  
....................    return(r);  
.................... }  
....................  
.................... //Arquivo de definição para o uso de display LCD  
.................... #include <mod_lcd.h> 
....................  /*****************************************************************************  
.................... /*                   Biblioteca de funções que o LCD irá usar                *  
.................... /*****************************************************************************  
....................   
....................   
.................... /*********** Rotina que envia um NIBBLE para o LCD ******************/  
....................   
.................... void envia_nibble_lcd(int dado)  
.................... {  
....................    //Carrega o NIBBLE baixo nas saidas dos pinos de dados  
....................    output_bit(lcd_db4,bit_test(dado,0));  
*
008A:  BTFSC  7D.0
008B:  GOTO   08E
008C:  BCF    08.4
008D:  GOTO   08F
008E:  BSF    08.4
008F:  BSF    03.5
0090:  BCF    08.4
....................    output_bit(lcd_db5,bit_test(dado,1));  
0091:  BTFSC  7D.1
0092:  GOTO   097
0093:  BCF    03.5
0094:  BCF    08.5
0095:  GOTO   099
0096:  BSF    03.5
0097:  BCF    03.5
0098:  BSF    08.5
0099:  BSF    03.5
009A:  BCF    08.5
....................    output_bit(lcd_db6,bit_test(dado,2));  
009B:  BTFSC  7D.2
009C:  GOTO   0A1
009D:  BCF    03.5
009E:  BCF    08.6
009F:  GOTO   0A3
00A0:  BSF    03.5
00A1:  BCF    03.5
00A2:  BSF    08.6
00A3:  BSF    03.5
00A4:  BCF    08.6
....................    output_bit(lcd_db7,bit_test(dado,3));  
00A5:  BTFSC  7D.3
00A6:  GOTO   0AB
00A7:  BCF    03.5
00A8:  BCF    08.7
00A9:  GOTO   0AD
00AA:  BSF    03.5
00AB:  BCF    03.5
00AC:  BSF    08.7
00AD:  BSF    03.5
00AE:  BCF    08.7
....................   
....................    //Gera um pulso no enable  
....................    output_high(lcd_enable);  
00AF:  BCF    06.0
00B0:  BCF    03.5
00B1:  BSF    06.0
....................    delay_us(1);  
00B2:  NOP
....................    output_low(lcd_enable);  
00B3:  BSF    03.5
00B4:  BCF    06.0
00B5:  BCF    03.5
00B6:  BCF    06.0
....................   
....................    return;  
.................... }  
00B7:  RETLW  00
....................   
....................   
.................... /*********** Rotina que envia um BYTE para o LCD ******************/  
....................   
.................... void envia_byte_lcd(boolean endereco,int dado)  
.................... {  
....................    //Seta o bit RS para endereco 0=comandos 1=dados  
....................    output_bit(lcd_rs,endereco);  
00B8:  MOVF   75,F
00B9:  BTFSS  03.2
00BA:  GOTO   0BD
00BB:  BCF    06.1
00BC:  GOTO   0BE
00BD:  BSF    06.1
00BE:  BSF    03.5
00BF:  BCF    06.1
....................    //Aguarda a estabilização do LCD  
....................    delay_us(100);  
00C0:  MOVLW  21
00C1:  MOVWF  77
00C2:  DECFSZ 77,F
00C3:  GOTO   0C2
....................    output_low(lcd_enable);  
00C4:  BCF    06.0
00C5:  BCF    03.5
00C6:  BCF    06.0
....................    //Envia a parte ALTA do byte primeiro  
....................    envia_nibble_lcd(dado>>4);  
00C7:  SWAPF  76,W
00C8:  MOVWF  7C
00C9:  MOVLW  0F
00CA:  ANDWF  7C,F
00CB:  MOVF   7C,W
00CC:  MOVWF  7D
00CD:  CALL   08A
....................    //Limpa a parte alta e envia a parte BAIXA  
....................    envia_nibble_lcd(dado & 0x0f);  
00CE:  MOVF   76,W
00CF:  ANDLW  0F
00D0:  MOVWF  7C
00D1:  MOVWF  7D
00D2:  CALL   08A
....................    //Abuarda 40us  
....................    delay_us(40);  
00D3:  MOVLW  0D
00D4:  MOVWF  77
00D5:  DECFSZ 77,F
00D6:  GOTO   0D5
....................    return;  
.................... }  
00D7:  RETLW  00
....................   
.................... /*********** Rotina que envia um CARACTERE para o LCD ******************/  
....................   
.................... void escreve_lcd(char c)  
.................... {  
....................    envia_byte_lcd(1,c);  
*
0215:  MOVLW  01
0216:  MOVWF  75
0217:  MOVF   72,W
0218:  MOVWF  76
0219:  CALL   0B8
.................... }  
021A:  RETLW  00
....................   
.................... /******************** Rotina LIMPA o LCD ******************************/  
....................   
.................... void limpa_lcd()  
.................... {  
....................    //Envia o comando estabelecido no datasheet  
....................    envia_byte_lcd(0,0x01);  
*
00D8:  CLRF   75
00D9:  MOVLW  01
00DA:  MOVWF  76
00DB:  CALL   0B8
....................    //Acuarda 2 milisegundos para a execussão da tarefa  
....................    delay_ms(2);  
00DC:  MOVLW  02
00DD:  MOVWF  70
00DE:  CALL   075
....................    return;  
.................... }  
00DF:  RETLW  00
....................   
.................... /************** Rotina que Posiciona o cursor do LCD ******************/  
....................   
.................... void lcd_pos_xy(byte x, byte y)  
.................... {  
....................    byte endereco;  
....................    //Se for linha 0 é a primeira linha se for 1 é a segunda  
....................    if (y!=1){  
*
021B:  DECFSZ 72,W
021C:  GOTO   21E
021D:  GOTO   221
....................       //Endereco da segunda linha na RAM do Display  
....................       endereco = 0x40;  
021E:  MOVLW  40
021F:  MOVWF  73
....................    } else {  
0220:  GOTO   222
....................       endereco = 0;  
0221:  CLRF   73
....................    }  
....................    //Soma o endereco do X  
....................    endereco += x-1;  
0222:  MOVLW  01
0223:  SUBWF  71,W
0224:  ADDWF  73,F
....................    //Envia o endereco combinado 0x80 é o da primeira posição  
....................    envia_byte_lcd(0,0x80|endereco);  
0225:  MOVF   73,W
0226:  IORLW  80
0227:  MOVWF  74
0228:  CLRF   75
0229:  MOVF   74,W
022A:  MOVWF  76
022B:  CALL   0B8
.................... }  
022C:  RETLW  00
....................   
.................... /****************** Rotina que INICIALIZA o LCD ***********************/  
....................   
.................... void inicializa_lcd()  
.................... {  
....................    //Garante que todos os pinos estejam em 0 (Zero)  
....................    output_low(lcd_db4);  
*
00E0:  BSF    03.5
00E1:  BCF    08.4
00E2:  BCF    03.5
00E3:  BCF    08.4
....................    output_low(lcd_db5);  
00E4:  BSF    03.5
00E5:  BCF    08.5
00E6:  BCF    03.5
00E7:  BCF    08.5
....................    output_low(lcd_db6);  
00E8:  BSF    03.5
00E9:  BCF    08.6
00EA:  BCF    03.5
00EB:  BCF    08.6
....................    output_low(lcd_db7);  
00EC:  BSF    03.5
00ED:  BCF    08.7
00EE:  BCF    03.5
00EF:  BCF    08.7
....................    output_low(lcd_rs);  
00F0:  BSF    03.5
00F1:  BCF    06.1
00F2:  BCF    03.5
00F3:  BCF    06.1
....................    output_low(lcd_enable);  
00F4:  BSF    03.5
00F5:  BCF    06.0
00F6:  BCF    03.5
00F7:  BCF    06.0
....................    //Aguarda a estabilização do LCD  
....................    delay_ms(15);  
00F8:  MOVLW  0F
00F9:  MOVWF  70
00FA:  CALL   075
....................   
....................    //Envia sequencia de comandos de inicialização básica  
....................    envia_nibble_lcd(0x03);  
00FB:  MOVLW  03
00FC:  MOVWF  7D
00FD:  CALL   08A
....................    delay_ms(5);  
00FE:  MOVLW  05
00FF:  MOVWF  70
0100:  CALL   075
....................    envia_nibble_lcd(0x03);  
0101:  MOVLW  03
0102:  MOVWF  7D
0103:  CALL   08A
....................    delay_ms(5);  
0104:  MOVLW  05
0105:  MOVWF  70
0106:  CALL   075
....................    envia_nibble_lcd(0x03);  
0107:  MOVLW  03
0108:  MOVWF  7D
0109:  CALL   08A
....................    delay_ms(5);  
010A:  MOVLW  05
010B:  MOVWF  70
010C:  CALL   075
....................    //Cursor HOME, comando que envia o cursor para a primeira posição  
....................    envia_nibble_lcd(0x02);  
010D:  MOVLW  02
010E:  MOVWF  7D
010F:  CALL   08A
....................    delay_ms(1);  
0110:  MOVLW  01
0111:  MOVWF  70
0112:  CALL   075
....................    //Function Set - Configura o LCD para 4bits, 2 linhas, fonte 5x7  
....................    envia_byte_lcd(0,0x28);  
0113:  CLRF   75
0114:  MOVLW  28
0115:  MOVWF  76
0116:  CALL   0B8
....................    //Display Control - Ligado sem cursor  
....................    envia_byte_lcd(0,0x0c);  
0117:  CLRF   75
0118:  MOVLW  0C
0119:  MOVWF  76
011A:  CALL   0B8
....................    limpa_lcd();  
011B:  CALL   0D8
....................    //Define o Entry Mode para deslocar o cursor para direita  
....................    envia_byte_lcd(0,0x06);  
011C:  CLRF   75
011D:  MOVLW  06
011E:  MOVWF  76
011F:  CALL   0B8
....................    return;  
.................... }  
0120:  BSF    0A.3
0121:  BSF    0A.4
0122:  GOTO   028 (RETURN)
....................   
.................... /************* Rotina que insere caracteres na CGRAM ***********************/  
.................... void cria_caractere(){  
....................    //endereca à CGRAM onde se podem criar os caracteres  
....................    //Envia o primeiro endereco da CGRAM (0x40)  
....................    envia_byte_lcd(0,0x40);  
0123:  CLRF   75
0124:  MOVLW  40
0125:  MOVWF  76
0126:  CALL   0B8
....................    //Envia as 8 linhas que formarao o caractere  
....................    envia_byte_lcd(1,0x00);     //0 0 0 0 0 0 0 0  
0127:  MOVLW  01
0128:  MOVWF  75
0129:  CLRF   76
012A:  CALL   0B8
....................    envia_byte_lcd(1,0x14);     //0 0 0 1 0 1 0 0  
012B:  MOVLW  01
012C:  MOVWF  75
012D:  MOVLW  14
012E:  MOVWF  76
012F:  CALL   0B8
....................    envia_byte_lcd(1,0x0A);     //0 0 0 0 1 0 1 0  
0130:  MOVLW  01
0131:  MOVWF  75
0132:  MOVLW  0A
0133:  MOVWF  76
0134:  CALL   0B8
....................    envia_byte_lcd(1,0x05);     //0 0 0 0 0 1 0 1  
0135:  MOVLW  01
0136:  MOVWF  75
0137:  MOVLW  05
0138:  MOVWF  76
0139:  CALL   0B8
....................    envia_byte_lcd(1,0x0A);     //0 0 0 0 1 0 1 0  
013A:  MOVLW  01
013B:  MOVWF  75
013C:  MOVLW  0A
013D:  MOVWF  76
013E:  CALL   0B8
....................    envia_byte_lcd(1,0x14);     //0 0 0 1 0 1 0 0  
013F:  MOVLW  01
0140:  MOVWF  75
0141:  MOVLW  14
0142:  MOVWF  76
0143:  CALL   0B8
....................    envia_byte_lcd(1,0x00);     //0 0 0 0 0 0 0 0  
0144:  MOVLW  01
0145:  MOVWF  75
0146:  CLRF   76
0147:  CALL   0B8
....................    envia_byte_lcd(1,0x00);     //0 0 0 0 0 0 0 0  //O ultimo e vazio por causa do cursor  
0148:  MOVLW  01
0149:  MOVWF  75
014A:  CLRF   76
014B:  CALL   0B8
....................    //Terminada a operação manda-se o reposicionamento do cursor  
....................    envia_byte_lcd(0,0x01);  
014C:  CLRF   75
014D:  MOVLW  01
014E:  MOVWF  76
014F:  CALL   0B8
....................    //Termino da criação do caractere " >> "  
....................      
.................... }  
0150:  BSF    0A.3
0151:  BSF    0A.4
0152:  GOTO   02D (RETURN)
....................  
.................... //Arquivo de definição para uso de funcoes de entrada da RS-232  
.................... #include <input_mod.c> 
....................  ///////////////////////////////////////////////////////////////////////////  
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////  
.................... //// This source code may only be used by licensed users of the CCS C  ////  
.................... //// compiler.  This source code may only be distributed to other      ////  
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////  
.................... //// or distribution is permitted without written permission.          ////  
.................... //// Derivative programs created using this software in object code    ////  
.................... //// form are not restricted in any way.                               ////  
.................... ///////////////////////////////////////////////////////////////////////////  
....................   
....................   
.................... #include <ctype.h> 
....................  ////////////////////////////////////////////////////////////////////////////  
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////  
.................... //// This source code may only be used by licensed users of the CCS C   ////  
.................... //// compiler.  This source code may only be distributed to other       ////  
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////  
.................... //// or distribution is permitted without written permission.           ////  
.................... //// Derivative programs created using this software in object code     ////  
.................... //// form are not restricted in any way.                                ////  
.................... ////////////////////////////////////////////////////////////////////////////  
....................   
.................... #ifndef _CTYPE  
.................... #define _CTYPE  
....................   
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")  
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")  
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")  
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")  
.................... #define isdigit(x)  isamong(x,"0123456789")  
.................... #define isspace(x)  (x==' ')  
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")  
.................... #define iscntrl(x)  (x<' ')  
.................... #define isprint(x)  (x>=' ')  
.................... #define isgraph(x)  (x>' ')  
.................... #define ispunct(x)  ((x>' ')&&!isalnum(x))  
....................   
.................... #endif  
....................   
....................  
....................   
.................... void get_string(char* s, int max) {  
....................    int len;  
....................    char c;  
....................   
....................    --max;  
....................    len=0;  
....................    do {  
....................      c=getc();  
....................      if(c==8) {  // Backspace  
....................         if(len>0) {  
....................           len--;  
....................           putc(c);  
....................           putc(' ');  
....................           putc(c);  
....................         }  
....................      } else if ((c>=' ')&&(c<='~'))  
....................        if(len<max) {  
....................          s[len++]=c;  
....................          putc(c);  
....................        }  
....................    } while(c!=13);  
....................    s[len]=0;  
.................... }  
....................  
.................... //Arquivo de definicao do sensor de umidade/temperatura SHT11  
.................... #include <sht11_drv.c> 
....................  ///////////////////////////////////////////////////////////////////////////////  
.................... #define ACK               0  
.................... // Command byte values         adr cmd  r/w  
.................... #define Reset        0x1e   // 000 1111  0  
.................... #define MeasureTemp  0x03   // 000 0001  1  
.................... #define MeasureHumi  0x05   // 000 0010  1  
.................... #define WrStatusReg  0x06   // 000 0011  0  
.................... #define RdStatusReg  0x07   // 000 0011  1  
.................... // Define Data & Clock Pins  
....................   
.................... //#define sht_data PIN_B7  
.................... //#define Sck  	   PIN_B6  
....................   
.................... short error, chkCRC, Acknowledge;  
.................... int TimeOut,err;  
....................   
.................... /////////////////////////////////////////////////////////  
.................... //  
.................... /////////////////////////////////////////////////////////  
.................... float CalcTempValues(long Lx){  
.................... //long CalcTempValues(long Lx){  
....................  long value;  
....................  float Fx;  
....................   
....................   Fx=0.01*(float)Lx;  
*
0F69:  MOVF   5F,W
0F6A:  MOVWF  6E
0F6B:  MOVF   5E,W
0F6C:  MOVWF  6D
0F6D:  BCF    0A.3
0F6E:  CALL   7E2
0F6F:  BSF    0A.3
0F70:  MOVLW  0A
0F71:  MOVWF  70
0F72:  MOVLW  D7
0F73:  MOVWF  6F
0F74:  MOVLW  23
0F75:  MOVWF  6E
0F76:  MOVLW  78
0F77:  MOVWF  6D
0F78:  MOVF   7A,W
0F79:  MOVWF  74
0F7A:  MOVF   79,W
0F7B:  MOVWF  73
0F7C:  MOVF   78,W
0F7D:  MOVWF  72
0F7E:  MOVF   77,W
0F7F:  MOVWF  71
0F80:  CALL   550
0F81:  MOVF   7A,W
0F82:  MOVWF  65
0F83:  MOVF   79,W
0F84:  MOVWF  64
0F85:  MOVF   78,W
0F86:  MOVWF  63
0F87:  MOVF   77,W
0F88:  MOVWF  62
....................   Fx=Fx-40;  
0F89:  BSF    03.1
0F8A:  MOVF   65,W
0F8B:  MOVWF  6C
0F8C:  MOVF   64,W
0F8D:  MOVWF  6B
0F8E:  MOVF   63,W
0F8F:  MOVWF  6A
0F90:  MOVF   62,W
0F91:  MOVWF  69
0F92:  CLRF   70
0F93:  CLRF   6F
0F94:  MOVLW  20
0F95:  MOVWF  6E
0F96:  MOVLW  84
0F97:  MOVWF  6D
0F98:  CALL   5E2
0F99:  MOVF   7A,W
0F9A:  MOVWF  65
0F9B:  MOVF   79,W
0F9C:  MOVWF  64
0F9D:  MOVF   78,W
0F9E:  MOVWF  63
0F9F:  MOVF   77,W
0FA0:  MOVWF  62
....................   //Value=Fx*10;  
....................   
....................   //return(value);  
....................   return(Fx);  
0FA1:  MOVF   62,W
0FA2:  MOVWF  77
0FA3:  MOVF   63,W
0FA4:  MOVWF  78
0FA5:  MOVF   64,W
0FA6:  MOVWF  79
0FA7:  MOVF   65,W
0FA8:  MOVWF  7A
.................... }  
.................... /////////////////////////////////////////////////////////  
.................... //  
.................... /////////////////////////////////////////////////////////  
.................... float CalcHumiValues(long Lx){  
.................... //long CalcHumiValues(long Lx){  
....................  long Value;  
....................  float Fx, Fy;  
....................   
....................   Fx=(float)Lx*(float)Lx;  
*
101C:  MOVF   5E,W
101D:  MOVWF  6E
101E:  MOVF   5D,W
101F:  MOVWF  6D
1020:  BCF    0A.4
1021:  CALL   7E2
1022:  BSF    0A.4
1023:  MOVF   77,W
1024:  MOVWF  69
1025:  MOVF   78,W
1026:  MOVWF  6A
1027:  MOVF   79,W
1028:  MOVWF  6B
1029:  MOVF   7A,W
102A:  MOVWF  6C
102B:  MOVF   5E,W
102C:  MOVWF  6E
102D:  MOVF   5D,W
102E:  MOVWF  6D
102F:  BCF    0A.4
1030:  CALL   7E2
1031:  BSF    0A.4
1032:  MOVF   6C,W
1033:  MOVWF  70
1034:  MOVF   6B,W
1035:  MOVWF  6F
1036:  MOVF   6A,W
1037:  MOVWF  6E
1038:  MOVF   69,W
1039:  MOVWF  6D
103A:  MOVF   7A,W
103B:  MOVWF  74
103C:  MOVF   79,W
103D:  MOVWF  73
103E:  MOVF   78,W
103F:  MOVWF  72
1040:  MOVF   77,W
1041:  MOVWF  71
1042:  BCF    0A.4
1043:  BSF    0A.3
1044:  CALL   550
1045:  BSF    0A.4
1046:  BCF    0A.3
1047:  MOVF   7A,W
1048:  MOVWF  64
1049:  MOVF   79,W
104A:  MOVWF  63
104B:  MOVF   78,W
104C:  MOVWF  62
104D:  MOVF   77,W
104E:  MOVWF  61
....................   Fx=Fx*(-0.0000028);  
104F:  MOVF   64,W
1050:  MOVWF  70
1051:  MOVF   63,W
1052:  MOVWF  6F
1053:  MOVF   62,W
1054:  MOVWF  6E
1055:  MOVF   61,W
1056:  MOVWF  6D
1057:  MOVLW  A2
1058:  MOVWF  74
1059:  MOVLW  E7
105A:  MOVWF  73
105B:  MOVLW  BB
105C:  MOVWF  72
105D:  MOVLW  6C
105E:  MOVWF  71
105F:  BCF    0A.4
1060:  BSF    0A.3
1061:  CALL   550
1062:  BSF    0A.4
1063:  BCF    0A.3
1064:  MOVF   7A,W
1065:  MOVWF  64
1066:  MOVF   79,W
1067:  MOVWF  63
1068:  MOVF   78,W
1069:  MOVWF  62
106A:  MOVF   77,W
106B:  MOVWF  61
....................   Fy=(float)Lx*0.0405;  
106C:  MOVF   5E,W
106D:  MOVWF  6E
106E:  MOVF   5D,W
106F:  MOVWF  6D
1070:  BCF    0A.4
1071:  CALL   7E2
1072:  BSF    0A.4
1073:  MOVF   77,W
1074:  MOVWF  69
1075:  MOVF   78,W
1076:  MOVWF  6A
1077:  MOVF   79,W
1078:  MOVWF  6B
1079:  MOVF   7A,W
107A:  MOVWF  6C
107B:  MOVWF  70
107C:  MOVF   79,W
107D:  MOVWF  6F
107E:  MOVF   78,W
107F:  MOVWF  6E
1080:  MOVF   77,W
1081:  MOVWF  6D
1082:  MOVLW  54
1083:  MOVWF  74
1084:  MOVLW  E3
1085:  MOVWF  73
1086:  MOVLW  25
1087:  MOVWF  72
1088:  MOVLW  7A
1089:  MOVWF  71
108A:  BCF    0A.4
108B:  BSF    0A.3
108C:  CALL   550
108D:  BSF    0A.4
108E:  BCF    0A.3
108F:  MOVF   7A,W
1090:  MOVWF  68
1091:  MOVF   79,W
1092:  MOVWF  67
1093:  MOVF   78,W
1094:  MOVWF  66
1095:  MOVF   77,W
1096:  MOVWF  65
....................   Fx=Fx+Fy;  
1097:  BCF    03.1
1098:  MOVF   64,W
1099:  MOVWF  6C
109A:  MOVF   63,W
109B:  MOVWF  6B
109C:  MOVF   62,W
109D:  MOVWF  6A
109E:  MOVF   61,W
109F:  MOVWF  69
10A0:  MOVF   68,W
10A1:  MOVWF  70
10A2:  MOVF   67,W
10A3:  MOVWF  6F
10A4:  MOVF   66,W
10A5:  MOVWF  6E
10A6:  MOVF   65,W
10A7:  MOVWF  6D
10A8:  BCF    0A.4
10A9:  BSF    0A.3
10AA:  CALL   5E2
10AB:  BSF    0A.4
10AC:  BCF    0A.3
10AD:  MOVF   7A,W
10AE:  MOVWF  64
10AF:  MOVF   79,W
10B0:  MOVWF  63
10B1:  MOVF   78,W
10B2:  MOVWF  62
10B3:  MOVF   77,W
10B4:  MOVWF  61
....................   Fx=Fx-4;  
10B5:  BSF    03.1
10B6:  MOVF   64,W
10B7:  MOVWF  6C
10B8:  MOVF   63,W
10B9:  MOVWF  6B
10BA:  MOVF   62,W
10BB:  MOVWF  6A
10BC:  MOVF   61,W
10BD:  MOVWF  69
10BE:  CLRF   70
10BF:  CLRF   6F
10C0:  CLRF   6E
10C1:  MOVLW  81
10C2:  MOVWF  6D
10C3:  BCF    0A.4
10C4:  BSF    0A.3
10C5:  CALL   5E2
10C6:  BSF    0A.4
10C7:  BCF    0A.3
10C8:  MOVF   7A,W
10C9:  MOVWF  64
10CA:  MOVF   79,W
10CB:  MOVWF  63
10CC:  MOVF   78,W
10CD:  MOVWF  62
10CE:  MOVF   77,W
10CF:  MOVWF  61
....................   //Value=Fx*10;  
....................   //return(value);  
....................   return(Fx);  
10D0:  MOVF   61,W
10D1:  MOVWF  77
10D2:  MOVF   62,W
10D3:  MOVWF  78
10D4:  MOVF   63,W
10D5:  MOVWF  79
10D6:  MOVF   64,W
10D7:  MOVWF  7A
.................... }  
.................... /////////////////////////////////////////////////////////  
.................... //  
.................... /////////////////////////////////////////////////////////  
.................... void TransmitStart(){  
....................   
....................   output_high(sht_data);  
*
0153:  BSF    03.5
0154:  BCF    05.0
0155:  BCF    03.5
0156:  BSF    05.0
....................   output_low(Sck);  delay_us(2);  
0157:  BSF    03.5
0158:  BCF    05.1
0159:  BCF    03.5
015A:  BCF    05.1
015B:  NOP
015C:  NOP
....................   output_high(SCK); delay_us(2);  
015D:  BSF    03.5
015E:  BCF    05.1
015F:  BCF    03.5
0160:  BSF    05.1
0161:  NOP
0162:  NOP
....................   output_low(sht_data); delay_us(2);  
0163:  BSF    03.5
0164:  BCF    05.0
0165:  BCF    03.5
0166:  BCF    05.0
0167:  NOP
0168:  NOP
....................   output_low(SCK);  delay_us(6);  
0169:  BSF    03.5
016A:  BCF    05.1
016B:  BCF    03.5
016C:  BCF    05.1
016D:  NOP
016E:  NOP
016F:  NOP
0170:  NOP
0171:  NOP
0172:  NOP
....................   output_high(SCK); delay_us(2);  
0173:  BSF    03.5
0174:  BCF    05.1
0175:  BCF    03.5
0176:  BSF    05.1
0177:  NOP
0178:  NOP
....................   output_high(sht_data);delay_us(2);  
0179:  BSF    03.5
017A:  BCF    05.0
017B:  BCF    03.5
017C:  BSF    05.0
017D:  NOP
017E:  NOP
....................   output_low(SCK);  delay_us(2);  
017F:  BSF    03.5
0180:  BCF    05.1
0181:  BCF    03.5
0182:  BCF    05.1
0183:  NOP
0184:  NOP
.................... }  
0185:  RETLW  00
.................... /////////////////////////////////////////////////////////  
.................... //  
.................... /////////////////////////////////////////////////////////  
.................... void RST_Connection(){  
....................  int i;  
....................   
....................   output_high(sht_data);  
0186:  BSF    03.5
0187:  BCF    05.0
0188:  BCF    03.5
0189:  BSF    05.0
....................   for(i=1;i<=10;++i) {  
018A:  MOVLW  01
018B:  MOVWF  57
018C:  MOVF   57,W
018D:  SUBLW  0A
018E:  BTFSS  03.0
018F:  GOTO   19E
....................       output_high(SCK); delay_us(2);  
0190:  BSF    03.5
0191:  BCF    05.1
0192:  BCF    03.5
0193:  BSF    05.1
0194:  NOP
0195:  NOP
....................       output_low(SCK);  delay_us(2);  
0196:  BSF    03.5
0197:  BCF    05.1
0198:  BCF    03.5
0199:  BCF    05.1
019A:  NOP
019B:  NOP
....................   }  
019C:  INCF   57,F
019D:  GOTO   18C
....................   TransmitStart();  
019E:  CALL   153
.................... }  
019F:  BSF    0A.3
01A0:  BSF    0A.4
01A1:  GOTO   037 (RETURN)
.................... /////////////////////////////////////////////////////////  
.................... //  
.................... /////////////////////////////////////////////////////////  
.................... void RST_Software(){  
....................   
.................... }  
.................... /////////////////////////////////////////////////////////  
.................... //  
.................... /////////////////////////////////////////////////////////  
.................... int ReadStatReg(int command){  
....................   
.................... }  
.................... /////////////////////////////////////////////////////////  
.................... //  
.................... /////////////////////////////////////////////////////////  
.................... long ReadValue(){  
....................  byte i, ByteHigh=0, ByteLow=0;  
*
0CE1:  CLRF   5F
0CE2:  CLRF   60
....................  long Lx;  
....................   
....................   for(i=1;i<=8;++i){                     // read high byte VALUE from SHT11  
0CE3:  MOVLW  01
0CE4:  MOVWF  5E
0CE5:  MOVF   5E,W
0CE6:  SUBLW  08
0CE7:  BTFSS  03.0
0CE8:  GOTO   500
....................      output_high(SCK);  
0CE9:  BSF    03.5
0CEA:  BCF    05.1
0CEB:  BCF    03.5
0CEC:  BSF    05.1
....................      delay_us(2);  
0CED:  NOP
0CEE:  NOP
....................      shift_left(&ByteHigh,1,input(sht_data));  
0CEF:  BSF    03.5
0CF0:  BSF    05.0
0CF1:  BCF    03.5
0CF2:  BTFSC  05.0
0CF3:  GOTO   4F6
0CF4:  BCF    03.0
0CF5:  GOTO   4F7
0CF6:  BSF    03.0
0CF7:  RLF    5F,F
....................      output_low(SCK);  
0CF8:  BSF    03.5
0CF9:  BCF    05.1
0CFA:  BCF    03.5
0CFB:  BCF    05.1
....................      delay_us(2);  
0CFC:  NOP
0CFD:  NOP
....................   }  
0CFE:  INCF   5E,F
0CFF:  GOTO   4E5
....................   output_low(sht_data);  
0D00:  BSF    03.5
0D01:  BCF    05.0
0D02:  BCF    03.5
0D03:  BCF    05.0
....................        delay_us(2);  
0D04:  NOP
0D05:  NOP
....................   output_high(SCK);  
0D06:  BSF    03.5
0D07:  BCF    05.1
0D08:  BCF    03.5
0D09:  BSF    05.1
....................   delay_us(2);  
0D0A:  NOP
0D0B:  NOP
....................   output_low(SCK);  
0D0C:  BSF    03.5
0D0D:  BCF    05.1
0D0E:  BCF    03.5
0D0F:  BCF    05.1
....................   output_float(sht_data);  
0D10:  BSF    03.5
0D11:  BSF    05.0
....................   delay_us(2);  
0D12:  NOP
0D13:  NOP
....................   
....................   for(i=1;i<=8;++i){                     // read low byte VALUE from SHT11  
0D14:  MOVLW  01
0D15:  BCF    03.5
0D16:  MOVWF  5E
0D17:  MOVF   5E,W
0D18:  SUBLW  08
0D19:  BTFSS  03.0
0D1A:  GOTO   532
....................      output_high(SCK);  
0D1B:  BSF    03.5
0D1C:  BCF    05.1
0D1D:  BCF    03.5
0D1E:  BSF    05.1
....................      delay_us(2);  
0D1F:  NOP
0D20:  NOP
....................      shift_left(&ByteLow,1,input(sht_data));  
0D21:  BSF    03.5
0D22:  BSF    05.0
0D23:  BCF    03.5
0D24:  BTFSC  05.0
0D25:  GOTO   528
0D26:  BCF    03.0
0D27:  GOTO   529
0D28:  BSF    03.0
0D29:  RLF    60,F
....................      output_low(SCK);  
0D2A:  BSF    03.5
0D2B:  BCF    05.1
0D2C:  BCF    03.5
0D2D:  BCF    05.1
....................      delay_us(2);  
0D2E:  NOP
0D2F:  NOP
....................   }  
0D30:  INCF   5E,F
0D31:  GOTO   517
....................   output_high(sht_data);  
0D32:  BSF    03.5
0D33:  BCF    05.0
0D34:  BCF    03.5
0D35:  BSF    05.0
....................        delay_us(2);  
0D36:  NOP
0D37:  NOP
....................   output_high(SCK);  
0D38:  BSF    03.5
0D39:  BCF    05.1
0D3A:  BCF    03.5
0D3B:  BSF    05.1
....................   delay_us(2);  
0D3C:  NOP
0D3D:  NOP
....................   output_low(SCK);  
0D3E:  BSF    03.5
0D3F:  BCF    05.1
0D40:  BCF    03.5
0D41:  BCF    05.1
....................   output_float(sht_data);  
0D42:  BSF    03.5
0D43:  BSF    05.0
....................   delay_us(2);  
0D44:  NOP
0D45:  NOP
....................   Lx=make16(ByteHigh,ByteLow);  
0D46:  BCF    03.5
0D47:  MOVF   5F,W
0D48:  MOVWF  62
0D49:  MOVF   60,W
0D4A:  MOVWF  61
....................   return(Lx);  
0D4B:  MOVF   61,W
0D4C:  MOVWF  78
0D4D:  MOVF   62,W
0D4E:  MOVWF  79
.................... }  
0D4F:  RETLW  00
.................... /////////////////////////////////////////////////////////  
.................... //  
.................... /////////////////////////////////////////////////////////  
.................... void SendCommand(int Command){  
....................  byte i;  
....................   
....................   for(i=128;i>0;i/=2){  
*
01A2:  MOVLW  80
01A3:  MOVWF  5F
01A4:  MOVF   5F,F
01A5:  BTFSC  03.2
01A6:  GOTO   1C4
....................      if(i & Command) output_high(sht_data);  
01A7:  MOVF   5F,W
01A8:  ANDWF  5E,W
01A9:  XORLW  00
01AA:  BTFSC  03.2
01AB:  GOTO   1B1
01AC:  BSF    03.5
01AD:  BCF    05.0
01AE:  BCF    03.5
01AF:  BSF    05.0
....................      else            output_low(sht_data);  
01B0:  GOTO   1B5
01B1:  BSF    03.5
01B2:  BCF    05.0
01B3:  BCF    03.5
01B4:  BCF    05.0
....................      delay_us(2);  
01B5:  NOP
01B6:  NOP
....................      output_high(SCK);  
01B7:  BSF    03.5
01B8:  BCF    05.1
01B9:  BCF    03.5
01BA:  BSF    05.1
....................      delay_us(2);  
01BB:  NOP
01BC:  NOP
....................      output_low(SCK);  
01BD:  BSF    03.5
01BE:  BCF    05.1
01BF:  BCF    03.5
01C0:  BCF    05.1
....................   }  
01C1:  BCF    03.0
01C2:  RRF    5F,F
01C3:  GOTO   1A4
....................   output_float(sht_data);  
01C4:  BSF    03.5
01C5:  BSF    05.0
....................   delay_us(2);  
01C6:  NOP
01C7:  NOP
....................   output_high(SCK);  
01C8:  BCF    05.1
01C9:  BCF    03.5
01CA:  BSF    05.1
....................   delay_us(2);  
01CB:  NOP
01CC:  NOP
....................   output_low(SCK);  
01CD:  BSF    03.5
01CE:  BCF    05.1
01CF:  BCF    03.5
01D0:  BCF    05.1
.................... }  
01D1:  RETLW  00
....................   
.................... /////////////////////////////////////////////////////////  
.................... //  
.................... /////////////////////////////////////////////////////////  
.................... int WriteStatReg(int command){  
....................    unsigned char i,error=0;  
01D2:  CLRF   59
....................      
....................    TransmitStart();  
01D3:  CALL   153
....................    SendCommand(WrStatusReg);  
01D4:  MOVLW  06
01D5:  MOVWF  5E
01D6:  CALL   1A2
....................    for (i=0x80;i>0;i=i/2) {  
01D7:  MOVLW  80
01D8:  MOVWF  58
01D9:  MOVF   58,F
01DA:  BTFSC  03.2
01DB:  GOTO   1FE
....................       if (i & command) {  
01DC:  MOVF   58,W
01DD:  ANDWF  57,W
01DE:  XORLW  00
01DF:  BTFSC  03.2
01E0:  GOTO   1E6
....................          output_high(sht_data);  
01E1:  BSF    03.5
01E2:  BCF    05.0
01E3:  BCF    03.5
01E4:  BSF    05.0
....................       } else {  
01E5:  GOTO   1EA
....................          output_low(sht_data);  
01E6:  BSF    03.5
01E7:  BCF    05.0
01E8:  BCF    03.5
01E9:  BCF    05.0
....................       }  
....................       delay_us(2);  
01EA:  NOP
01EB:  NOP
....................       output_high(SCK);       //Clock in SCK  
01EC:  BSF    03.5
01ED:  BCF    05.1
01EE:  BCF    03.5
01EF:  BSF    05.1
....................       delay_us(5);            //Pulse width aprox 5 us  
01F0:  NOP
01F1:  NOP
01F2:  NOP
01F3:  NOP
01F4:  NOP
....................       output_low(SCK);  
01F5:  BSF    03.5
01F6:  BCF    05.1
01F7:  BCF    03.5
01F8:  BCF    05.1
....................       delay_us(2);            //Wait 2 us  
01F9:  NOP
01FA:  NOP
....................    }  
01FB:  BCF    03.0
01FC:  RRF    58,F
01FD:  GOTO   1D9
....................    output_high(sht_data);     //Release Data-Line  
01FE:  BSF    03.5
01FF:  BCF    05.0
0200:  BCF    03.5
0201:  BSF    05.0
....................    output_high(SCK);          //Clock number 9 for ACK  
0202:  BSF    03.5
0203:  BCF    05.1
0204:  BCF    03.5
0205:  BSF    05.1
....................    error=input(sht_data);     //Check ACK (Data will be 0 in case of OK)  
0206:  BSF    03.5
0207:  BSF    05.0
0208:  BCF    03.5
0209:  CLRF   59
020A:  BTFSC  05.0
020B:  INCF   59,F
....................    output_low(SCK);  
020C:  BSF    03.5
020D:  BCF    05.1
020E:  BCF    03.5
020F:  BCF    05.1
....................    return error;              //error=1 in case of NO ACK  
0210:  MOVF   59,W
0211:  MOVWF  78
.................... }  
0212:  BSF    0A.3
0213:  BSF    0A.4
0214:  GOTO   03D (RETURN)
....................   
.................... /////////////////////////////////////////////////////////  
.................... //  
.................... /////////////////////////////////////////////////////////  
.................... float ReadTemperature(){  
.................... //long ReadTemperature(){  
....................  short Acknowledge;  
....................  long Lx; //,Value;  
....................  float Value;  
....................   
....................   TransmitStart();  
*
0F51:  BCF    0A.3
0F52:  CALL   153
0F53:  BSF    0A.3
....................   SendCommand(MeasureTemp);  
0F54:  MOVLW  03
0F55:  MOVWF  5E
0F56:  BCF    0A.3
0F57:  CALL   1A2
0F58:  BSF    0A.3
....................   while(input(sht_data));  
0F59:  BSF    03.5
0F5A:  BSF    05.0
0F5B:  BCF    03.5
0F5C:  BTFSC  05.0
0F5D:  GOTO   759
....................   delay_us(2);  
0F5E:  NOP
0F5F:  NOP
....................   Lx=ReadValue();                        // Read temperature value  
0F60:  CALL   4E1
0F61:  MOVF   79,W
0F62:  MOVWF  59
0F63:  MOVF   78,W
0F64:  MOVWF  58
....................   Value=CalcTempValues(Lx);  
0F65:  MOVF   59,W
0F66:  MOVWF  5F
0F67:  MOVF   58,W
0F68:  MOVWF  5E
*
0FA9:  MOVF   7A,W
0FAA:  MOVWF  5D
0FAB:  MOVF   79,W
0FAC:  MOVWF  5C
0FAD:  MOVF   78,W
0FAE:  MOVWF  5B
0FAF:  MOVF   77,W
0FB0:  MOVWF  5A
....................   return(Value);  
0FB1:  MOVF   5A,W
0FB2:  MOVWF  77
0FB3:  MOVF   5B,W
0FB4:  MOVWF  78
0FB5:  MOVF   5C,W
0FB6:  MOVWF  79
0FB7:  MOVF   5D,W
0FB8:  MOVWF  7A
.................... }  
0FB9:  BSF    0A.3
0FBA:  BSF    0A.4
0FBB:  GOTO   21C (RETURN)
.................... /////////////////////////////////////////////////////////  
.................... //  
.................... /////////////////////////////////////////////////////////  
.................... long ReadHumidity(){  
.................... //long ReadHumidity(){  
....................  long Lx; //,Value;  
....................  float Value;  
....................   
....................   TransmitStart();  
*
1000:  BCF    0A.4
1001:  CALL   153
1002:  BSF    0A.4
....................   SendCommand(MeasureHumi);  
1003:  MOVLW  05
1004:  MOVWF  5E
1005:  BCF    0A.4
1006:  CALL   1A2
1007:  BSF    0A.4
....................   while(input(sht_data));  
1008:  BSF    03.5
1009:  BSF    05.0
100A:  BCF    03.5
100B:  BTFSC  05.0
100C:  GOTO   008
....................   delay_us(2);  
100D:  NOP
100E:  NOP
....................   Lx=ReadValue();                        // Read humidity value  
100F:  BCF    0A.4
1010:  BSF    0A.3
1011:  CALL   4E1
1012:  BSF    0A.4
1013:  BCF    0A.3
1014:  MOVF   79,W
1015:  MOVWF  58
1016:  MOVF   78,W
1017:  MOVWF  57
....................   Value=CalcHumiValues(Lx);  
1018:  MOVF   58,W
1019:  MOVWF  5E
101A:  MOVF   57,W
101B:  MOVWF  5D
*
10D8:  MOVF   7A,W
10D9:  MOVWF  5C
10DA:  MOVF   79,W
10DB:  MOVWF  5B
10DC:  MOVF   78,W
10DD:  MOVWF  5A
10DE:  MOVF   77,W
10DF:  MOVWF  59
....................   return(Value);  
10E0:  MOVF   5C,W
10E1:  MOVWF  60
10E2:  MOVF   5B,W
10E3:  MOVWF  5F
10E4:  MOVF   5A,W
10E5:  MOVWF  5E
10E6:  MOVF   59,W
10E7:  MOVWF  5D
10E8:  BCF    0A.4
10E9:  BSF    0A.3
10EA:  CALL   7BC
10EB:  BSF    0A.4
10EC:  BCF    0A.3
10ED:  MOVF   79,W
.................... }  
10EE:  BSF    0A.3
10EF:  BSF    0A.4
10F0:  GOTO   227 (RETURN)
....................  
.................... //Arquivo de definição para escrita de variáveis longas na eeprom  
.................... #include <eeprom.h> 
....................  /*******************************************************************************  
.................... *             FUNCOES ESPECIFICAS PARA GRAVAR FLOAT NA EEPROM                  *  
.................... *******************************************************************************/  
....................   
.................... // Used to adjust the address range  
.................... #ifndef INT_EEPROM_ADDRESS  
....................    #define INT_EEPROM_ADDRESS int8  
.................... #endif  
....................   
.................... // Escreve um número de ponto flutuante na EEPROM interna  
.................... // Parametros 1) Um endereço da EEPROM (4 Endereços são usados para Float)  
.................... //            2) O número flutuante a ser escrito na eeprom  
....................   
.................... void write_float_eeprom(INT_EEPROM_ADDRESS address, float data){  
....................   
....................   int8 i;  
....................   
....................   for(i = 0; i < 4; ++i){  
10F1:  CLRF   5C
10F2:  MOVF   5C,W
10F3:  SUBLW  03
10F4:  BTFSS  03.0
10F5:  GOTO   120
....................     write_eeprom(address + i,*(&data + i));  
10F6:  MOVF   5C,W
10F7:  ADDWF  57,W
10F8:  MOVWF  5D
10F9:  MOVLW  58
10FA:  ADDWF  5C,W
10FB:  MOVWF  04
10FC:  MOVF   00,W
10FD:  MOVWF  5E
10FE:  BSF    03.6
10FF:  CLRF   0E
1100:  BCF    03.6
1101:  MOVF   5D,W
1102:  BSF    03.6
1103:  MOVWF  0D
1104:  BCF    03.6
1105:  MOVF   5E,W
1106:  BSF    03.6
1107:  MOVWF  0C
1108:  BSF    03.5
1109:  BCF    0C.7
110A:  BSF    0C.2
110B:  BCF    03.5
110C:  BCF    03.6
110D:  MOVF   0B,W
110E:  MOVWF  77
110F:  BCF    0B.7
1110:  BSF    03.5
1111:  BSF    03.6
1112:  MOVLW  55
1113:  MOVWF  0D
1114:  MOVLW  AA
1115:  MOVWF  0D
1116:  BSF    0C.1
1117:  BTFSC  0C.1
1118:  GOTO   117
1119:  BCF    0C.2
111A:  MOVF   77,W
111B:  BCF    03.5
111C:  BCF    03.6
111D:  IORWF  0B,F
....................   }  
111E:  INCF   5C,F
111F:  GOTO   0F2
.................... }  
1120:  RETLW  00
....................   
.................... // Lê um número de ponto flutuante da eeprom  
.................... // Parametros: Um endereço da EEPROM (endereço inicial)  
.................... // Retorna um ponto flutuante que foi lido no endereço da EEPROM  
....................   
.................... float read_float_eeprom(INT_EEPROM_ADDRESS address){  
....................   
....................   int8 i;  
....................   float data;  
....................   
....................   for(i = 0; i < 4; ++i){  
*
02A6:  CLRF   58
02A7:  MOVF   58,W
02A8:  SUBLW  03
02A9:  BTFSS  03.0
02AA:  GOTO   2C0
....................     *(&data + i) = read_eeprom(address + i);  
02AB:  MOVLW  59
02AC:  ADDWF  58,W
02AD:  MOVWF  04
02AE:  MOVF   58,W
02AF:  ADDWF  57,W
02B0:  MOVWF  5E
02B1:  BSF    03.6
02B2:  CLRF   0E
02B3:  BCF    03.6
02B4:  MOVF   5E,W
02B5:  BSF    03.6
02B6:  MOVWF  0D
02B7:  BSF    03.5
02B8:  BCF    0C.7
02B9:  BSF    0C.0
02BA:  BCF    03.5
02BB:  MOVF   0C,W
02BC:  MOVWF  00
....................   }  
02BD:  BCF    03.6
02BE:  INCF   58,F
02BF:  GOTO   2A7
....................   return data;  
02C0:  MOVF   59,W
02C1:  MOVWF  77
02C2:  MOVF   5A,W
02C3:  MOVWF  78
02C4:  MOVF   5B,W
02C5:  MOVWF  79
02C6:  MOVF   5C,W
02C7:  MOVWF  7A
.................... }  
02C8:  RETLW  00
....................   
.................... // Lê um número de 16 bits da eeprom interna  
.................... // Parametros: Um endereço da EEPROM (endereço inicial)  
.................... // Retorna um inteiro long que foi lido no endereço da EEPROM  
....................   
.................... long int read_eeprom_16(long int endereco){  
....................   int8 pLow, pHigh;  
....................   long resultado;  
....................   pHigh = read_eeprom(endereco);  
*
022D:  MOVF   58,W
022E:  BSF    03.6
022F:  MOVWF  0E
0230:  BCF    03.6
0231:  MOVF   57,W
0232:  BSF    03.6
0233:  MOVWF  0D
0234:  BSF    03.5
0235:  BCF    0C.7
0236:  BSF    0C.0
0237:  BCF    03.5
0238:  MOVF   0C,W
0239:  BCF    03.6
023A:  MOVWF  5A
....................   endereco++;  
023B:  INCF   57,F
023C:  BTFSC  03.2
023D:  INCF   58,F
....................   pLow =  read_eeprom(endereco);  
023E:  MOVF   58,W
023F:  BSF    03.6
0240:  MOVWF  0E
0241:  BCF    03.6
0242:  MOVF   57,W
0243:  BSF    03.6
0244:  MOVWF  0D
0245:  BSF    03.5
0246:  BCF    0C.7
0247:  BSF    0C.0
0248:  BCF    03.5
0249:  MOVF   0C,W
024A:  BCF    03.6
024B:  MOVWF  59
....................   resultado=(pHigh<<8);  
024C:  MOVF   5A,W
024D:  MOVWF  5C
024E:  CLRF   5B
....................   resultado+=pLow;  
024F:  MOVF   59,W
0250:  ADDWF  5B,F
0251:  BTFSC  03.0
0252:  INCF   5C,F
....................   return resultado;  
0253:  MOVF   5B,W
0254:  MOVWF  78
0255:  MOVF   5C,W
0256:  MOVWF  79
.................... }  
0257:  BSF    0A.3
0258:  BSF    0A.4
0259:  GOTO   11B (RETURN)
....................   
.................... // Escreve um dado de 16 bits na eeprom interna  
.................... // endereco - é o endereço da memória a ser escrito  
.................... // dado - é a informação a ser armazenada  
....................   
.................... void write_eeprom_16(int endereco, long dado){  
....................   int8 pLow, pHigh;  
....................   pLow = dado;  
025A:  MOVF   66,W
025B:  MOVWF  68
....................   pHigh = (dado >> 8);  
025C:  MOVF   67,W
025D:  MOVWF  69
....................   write_eeprom(endereco,pHigh);  
025E:  BSF    03.6
025F:  CLRF   0E
0260:  BCF    03.6
0261:  MOVF   65,W
0262:  BSF    03.6
0263:  MOVWF  0D
0264:  BCF    03.6
0265:  MOVF   69,W
0266:  BSF    03.6
0267:  MOVWF  0C
0268:  BSF    03.5
0269:  BCF    0C.7
026A:  BSF    0C.2
026B:  BCF    03.5
026C:  BCF    03.6
026D:  MOVF   0B,W
026E:  MOVWF  77
026F:  BCF    0B.7
0270:  BSF    03.5
0271:  BSF    03.6
0272:  MOVLW  55
0273:  MOVWF  0D
0274:  MOVLW  AA
0275:  MOVWF  0D
0276:  BSF    0C.1
0277:  BTFSC  0C.1
0278:  GOTO   277
0279:  BCF    0C.2
027A:  MOVF   77,W
027B:  BCF    03.5
027C:  BCF    03.6
027D:  IORWF  0B,F
....................   delay_ms(12);  
027E:  MOVLW  0C
027F:  MOVWF  70
0280:  CALL   075
....................   endereco++;  
0281:  INCF   65,F
....................   write_eeprom(endereco,pLow);  
0282:  BSF    03.6
0283:  CLRF   0E
0284:  BCF    03.6
0285:  MOVF   65,W
0286:  BSF    03.6
0287:  MOVWF  0D
0288:  BCF    03.6
0289:  MOVF   68,W
028A:  BSF    03.6
028B:  MOVWF  0C
028C:  BSF    03.5
028D:  BCF    0C.7
028E:  BSF    0C.2
028F:  BCF    03.5
0290:  BCF    03.6
0291:  MOVF   0B,W
0292:  MOVWF  77
0293:  BCF    0B.7
0294:  BSF    03.5
0295:  BSF    03.6
0296:  MOVLW  55
0297:  MOVWF  0D
0298:  MOVLW  AA
0299:  MOVWF  0D
029A:  BSF    0C.1
029B:  BTFSC  0C.1
029C:  GOTO   29B
029D:  BCF    0C.2
029E:  MOVF   77,W
029F:  BCF    03.5
02A0:  BCF    03.6
02A1:  IORWF  0B,F
....................   delay_ms(12);  
02A2:  MOVLW  0C
02A3:  MOVWF  70
02A4:  CALL   075
.................... }  
02A5:  RETLW  00
....................   
....................  
.................... //Arquivo de definição para operaçao com strings e definicoes  
.................... #include <stdlib_mod.h> 
....................  ///////////////////////////////////////////////////////////////////////////  
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////  
.................... //// This source code may only be used by licensed users of the CCS C  ////  
.................... //// compiler.  This source code may only be distributed to other      ////  
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////  
.................... //// or distribution is permitted without written permission.          ////  
.................... //// Derivative programs created using this software in object code    ////  
.................... //// form are not restricted in any way.                               ////  
.................... ///////////////////////////////////////////////////////////////////////////  
....................   
.................... #ifndef _STDLIB  
.................... #define _STDLIB  
....................   
.................... //---------------------------------------------------------------------------  
.................... // Definitions and types  
.................... //---------------------------------------------------------------------------  
....................   
.................... #ifndef RAND_MAX  
.................... #define RAND_MAX  32767    // The value of which is the maximum value  
....................                            // ... returned by the rand function  
.................... #endif  
....................   
.................... typedef struct {  
....................    signed int quot;  
....................    signed int rem;  
.................... } div_t;  
....................   
.................... typedef struct {  
....................    signed long quot;  
....................    signed long rem;  
.................... } ldiv_t;  
....................   
.................... #include <stddef.h> 
....................  ///////////////////////////////////////////////////////////////////////////  
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////  
.................... //// This source code may only be used by licensed users of the CCS C  ////  
.................... //// compiler.  This source code may only be distributed to other      ////  
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////  
.................... //// or distribution is permitted without written permission.          ////  
.................... //// Derivative programs created using this software in object code    ////  
.................... //// form are not restricted in any way.                               ////  
.................... ///////////////////////////////////////////////////////////////////////////  
....................   
.................... #ifndef _STDDEF  
....................   
.................... #define _STDDEF  
....................   
.................... #if sizeof(int *)==1  
.................... #define ptrdiff_t int  
.................... #else  
.................... #define ptrdiff_t long  
.................... #endif  
....................   
.................... #define size_t int  
.................... #define wchar_t char  
.................... #define NULL 0  
....................   
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)  
....................   
.................... #endif  
....................  
....................   
.................... //---------------------------------------------------------------------------  
.................... // String conversion functions  
.................... //---------------------------------------------------------------------------  
.................... /***********************************************************/  
.................... /*Search functions*/  
.................... /* standard template: void *memchr(const char *s, int c).  
....................    Finds first occurrence of c in n characters of s */  
....................   
.................... char *memchr(void *s,int c,size_t n)  
.................... {  
....................    char uc;  
....................    char *su;  
....................    uc=c;  
*
04FE:  BSF    03.5
04FF:  MOVF   47,W
0500:  MOVWF  49
....................    for(su=s;0<n;++su,--n)  
0501:  MOVF   46,W
0502:  MOVWF  4A
0503:  MOVF   48,W
0504:  SUBLW  00
0505:  BTFSC  03.0
0506:  GOTO   513
....................       if(*su==uc)  
0507:  MOVF   4A,W
0508:  MOVWF  04
0509:  MOVF   49,W
050A:  SUBWF  00,W
050B:  BTFSS  03.2
050C:  GOTO   510
....................       return su;  
050D:  MOVF   4A,W
050E:  MOVWF  78
050F:  GOTO   515
0510:  INCF   4A,F
0511:  DECF   48,F
0512:  GOTO   503
....................    return NULL;  
0513:  MOVLW  00
0514:  MOVWF  78
.................... }  
0515:  BCF    03.5
0516:  RETLW  00
....................   
.................... int *strlen(char *s)  
.................... {  
....................    char *sc;  
....................   
....................    for (sc = s; *sc != 0; sc++);  
....................    return(sc - s);  
.................... }  
....................   
.................... /* standard template:  
....................    char *strncpy(char *s1, const char *s2, size_t n).  
....................    Copies max of n characters (not following ending '\0')  
....................    from s2 in s1; if s2 has less than n characters, appends 0 */  
....................   
.................... char *strncpy(char *s1, char *s2, size_t n)  
.................... {  
....................   char *s;  
....................   
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)  
....................      *s++ = *s2++;  
....................   for (; n > 0; n--)  
....................      *s++ = '\0';  
....................   
....................   return(s1);  
.................... }  
....................   
.................... signed long strtol(char *s,char *endptr,signed int base);  
....................   
.................... /* Standard template: long strtoul(char * s,char *endptr,signed int base)  
....................  * converts the initial portion of the string s, represented as an  
....................  * integral value of radix base to a unsigned long.  
....................  * returns the converted value if any, 0 otherwise  
....................  * the final string is returned in the endptr, if endptr is not null  
....................  */  
....................   
....................   
.................... signed long strtol(char *s,char *endptr,signed int base)  
.................... {  
....................    char *sc,*s1,*sd;  
....................    signed long x=0;  
*
0530:  CLRF   6B
0531:  CLRF   6C
....................    char sign;  
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";  
0532:  MOVLW  30
0533:  BSF    03.5
0534:  MOVWF  20
0535:  MOVLW  31
0536:  MOVWF  21
0537:  MOVLW  32
0538:  MOVWF  22
0539:  MOVLW  33
053A:  MOVWF  23
053B:  MOVLW  34
053C:  MOVWF  24
053D:  MOVLW  35
053E:  MOVWF  25
053F:  MOVLW  36
0540:  MOVWF  26
0541:  MOVLW  37
0542:  MOVWF  27
0543:  MOVLW  38
0544:  MOVWF  28
0545:  MOVLW  39
0546:  MOVWF  29
0547:  MOVLW  61
0548:  MOVWF  2A
0549:  MOVLW  62
054A:  MOVWF  2B
054B:  MOVLW  63
054C:  MOVWF  2C
054D:  MOVLW  64
054E:  MOVWF  2D
054F:  MOVLW  65
0550:  MOVWF  2E
0551:  MOVLW  66
0552:  MOVWF  2F
0553:  MOVLW  67
0554:  MOVWF  30
0555:  MOVLW  68
0556:  MOVWF  31
0557:  MOVLW  69
0558:  MOVWF  32
0559:  MOVLW  6A
055A:  MOVWF  33
055B:  MOVLW  6B
055C:  MOVWF  34
055D:  MOVLW  6C
055E:  MOVWF  35
055F:  MOVLW  6D
0560:  MOVWF  36
0561:  MOVLW  6E
0562:  MOVWF  37
0563:  MOVLW  6F
0564:  MOVWF  38
0565:  MOVLW  70
0566:  MOVWF  39
0567:  MOVLW  71
0568:  MOVWF  3A
0569:  MOVLW  73
056A:  MOVWF  3B
056B:  MOVLW  74
056C:  MOVWF  3C
056D:  MOVLW  75
056E:  MOVWF  3D
056F:  MOVLW  76
0570:  MOVWF  3E
0571:  MOVLW  77
0572:  MOVWF  3F
0573:  MOVLW  78
0574:  MOVWF  40
0575:  MOVLW  79
0576:  MOVWF  41
0577:  MOVLW  7A
0578:  MOVWF  42
0579:  CLRF   43
....................    for(sc=s;isspace(*sc);++sc);  
057A:  BCF    03.5
057B:  MOVF   65,W
057C:  MOVWF  68
057D:  MOVF   68,W
057E:  MOVWF  04
057F:  MOVF   00,W
0580:  SUBLW  20
0581:  BTFSS  03.2
0582:  GOTO   585
0583:  INCF   68,F
0584:  GOTO   57D
....................    sign=*sc=='-'||*sc=='+'?sc++:'+';  
0585:  MOVF   68,W
0586:  MOVWF  04
0587:  MOVF   00,W
0588:  SUBLW  2D
0589:  BTFSC  03.2
058A:  GOTO   591
058B:  MOVF   68,W
058C:  MOVWF  04
058D:  MOVF   00,W
058E:  SUBLW  2B
058F:  BTFSS  03.2
0590:  GOTO   596
0591:  MOVF   68,W
0592:  INCF   68,F
0593:  MOVWF  04
0594:  MOVF   00,W
0595:  GOTO   597
0596:  MOVLW  2B
0597:  MOVWF  6D
....................    if (base <0 || base ==1|| base >36) // invalid base  
0598:  BTFSC  67.7
0599:  GOTO   5A3
059A:  DECFSZ 67,W
059B:  GOTO   59D
059C:  GOTO   5A3
059D:  BTFSC  67.7
059E:  GOTO   5AF
059F:  MOVF   67,W
05A0:  SUBLW  24
05A1:  BTFSC  03.0
05A2:  GOTO   5AF
....................    {  
....................       if (endptr)  
05A3:  MOVF   66,F
05A4:  BTFSC  03.2
05A5:  GOTO   5AA
....................       {  
....................         *((char *)endptr)=s;  
05A6:  MOVF   66,W
05A7:  MOVWF  04
05A8:  MOVF   65,W
05A9:  MOVWF  00
....................       }  
....................       return 0;  
05AA:  MOVLW  00
05AB:  MOVWF  78
05AC:  MOVWF  79
05AD:  GOTO   6A9
....................    }  
....................    else if (base)  
05AE:  GOTO   615
05AF:  MOVF   67,F
05B0:  BTFSC  03.2
05B1:  GOTO   5EC
....................    {  
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))  
05B2:  MOVF   67,W
05B3:  SUBLW  10
05B4:  BTFSS  03.2
05B5:  GOTO   5CC
05B6:  MOVF   68,W
05B7:  MOVWF  04
05B8:  MOVF   00,W
05B9:  SUBLW  30
05BA:  BTFSS  03.2
05BB:  GOTO   5CC
05BC:  MOVLW  01
05BD:  ADDWF  68,W
05BE:  MOVWF  04
05BF:  MOVF   00,W
05C0:  SUBLW  78
05C1:  BTFSC  03.2
05C2:  GOTO   5CA
05C3:  MOVLW  01
05C4:  ADDWF  68,W
05C5:  MOVWF  04
05C6:  MOVF   00,W
05C7:  SUBLW  58
05C8:  BTFSS  03.2
05C9:  GOTO   5CC
....................          sc+=2;  
05CA:  MOVLW  02
05CB:  ADDWF  68,F
....................       if(base==8 && *sc =='0')  
05CC:  MOVF   67,W
05CD:  SUBLW  08
05CE:  BTFSS  03.2
05CF:  GOTO   5D8
05D0:  MOVF   68,W
05D1:  MOVWF  04
05D2:  MOVF   00,W
05D3:  SUBLW  30
05D4:  BTFSS  03.2
05D5:  GOTO   5D8
....................          sc+=1;  
05D6:  MOVLW  01
05D7:  ADDWF  68,F
....................       if(base==2 && *sc =='0'&&sc[1]=='b')  
05D8:  MOVF   67,W
05D9:  SUBLW  02
05DA:  BTFSS  03.2
05DB:  GOTO   5EB
05DC:  MOVF   68,W
05DD:  MOVWF  04
05DE:  MOVF   00,W
05DF:  SUBLW  30
05E0:  BTFSS  03.2
05E1:  GOTO   5EB
05E2:  MOVLW  01
05E3:  ADDWF  68,W
05E4:  MOVWF  04
05E5:  MOVF   00,W
05E6:  SUBLW  62
05E7:  BTFSS  03.2
05E8:  GOTO   5EB
....................          sc+=2;  
05E9:  MOVLW  02
05EA:  ADDWF  68,F
....................   
....................    }  
....................    else if(*sc!='0') // base is 0, find base  
05EB:  GOTO   615
05EC:  MOVF   68,W
05ED:  MOVWF  04
05EE:  MOVF   00,W
05EF:  SUBLW  30
05F0:  BTFSC  03.2
05F1:  GOTO   5F5
....................       base=10;  
05F2:  MOVLW  0A
05F3:  MOVWF  67
....................    else if (sc[1]=='x' || sc[1]=='X')  
05F4:  GOTO   615
05F5:  MOVLW  01
05F6:  ADDWF  68,W
05F7:  MOVWF  04
05F8:  MOVF   00,W
05F9:  SUBLW  78
05FA:  BTFSC  03.2
05FB:  GOTO   603
05FC:  MOVLW  01
05FD:  ADDWF  68,W
05FE:  MOVWF  04
05FF:  MOVF   00,W
0600:  SUBLW  58
0601:  BTFSS  03.2
0602:  GOTO   608
....................       base =16,sc+=2;  
0603:  MOVLW  10
0604:  MOVWF  67
0605:  MOVLW  02
0606:  ADDWF  68,F
....................    else if(sc[1]=='b')  
0607:  GOTO   615
0608:  MOVLW  01
0609:  ADDWF  68,W
060A:  MOVWF  04
060B:  MOVF   00,W
060C:  SUBLW  62
060D:  BTFSS  03.2
060E:  GOTO   613
....................       base=2,sc+=2;  
060F:  MOVLW  02
0610:  MOVWF  67
0611:  ADDWF  68,F
....................    else  
0612:  GOTO   615
....................       base=8;  
0613:  MOVLW  08
0614:  MOVWF  67
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes  
0615:  MOVF   68,W
0616:  MOVWF  69
0617:  MOVF   68,W
0618:  MOVWF  04
0619:  MOVF   00,W
061A:  SUBLW  30
061B:  BTFSS  03.2
061C:  GOTO   61F
061D:  INCF   68,F
061E:  GOTO   617
....................   
....................    sd=memchr(digits,tolower(*sc),base);  
061F:  MOVF   68,W
0620:  MOVWF  04
0621:  MOVF   00,W
0622:  MOVWF  6E
0623:  SUBLW  40
0624:  BTFSC  03.0
0625:  GOTO   62D
0626:  MOVF   6E,W
0627:  SUBLW  5A
0628:  BTFSS  03.0
0629:  GOTO   62D
062A:  MOVF   6E,W
062B:  IORLW  20
062C:  GOTO   62E
062D:  MOVF   6E,W
062E:  MOVWF  6F
062F:  MOVLW  A0
0630:  BSF    03.5
0631:  MOVWF  46
0632:  BCF    03.5
0633:  MOVF   6E,W
0634:  BSF    03.5
0635:  MOVWF  47
0636:  BCF    03.5
0637:  MOVF   67,W
0638:  BSF    03.5
0639:  MOVWF  48
063A:  BCF    03.5
063B:  CALL   4FE
063C:  MOVF   78,W
063D:  MOVWF  6A
....................    for(;sd!=0;)  
063E:  MOVF   6A,F
063F:  BTFSC  03.2
0640:  GOTO   686
....................    {  
....................       x=x*base+(int16)(sd-digits);  
0641:  CLRF   7A
0642:  MOVF   67,W
0643:  MOVWF  77
0644:  BTFSC  67.7
0645:  DECF   7A,F
0646:  MOVWF  6E
0647:  MOVF   7A,W
0648:  MOVWF  6F
0649:  MOVF   6C,W
064A:  BSF    03.5
064B:  MOVWF  47
064C:  BCF    03.5
064D:  MOVF   6B,W
064E:  BSF    03.5
064F:  MOVWF  46
0650:  BCF    03.5
0651:  MOVF   7A,W
0652:  BSF    03.5
0653:  MOVWF  49
0654:  BCF    03.5
0655:  MOVF   6E,W
0656:  BSF    03.5
0657:  MOVWF  48
0658:  BCF    03.5
0659:  GOTO   517
065A:  MOVLW  A0
065B:  SUBWF  6A,W
065C:  CLRF   7A
065D:  ADDWF  78,W
065E:  MOVWF  6B
065F:  MOVF   79,W
0660:  MOVWF  6C
0661:  BTFSC  03.0
0662:  INCF   6C,F
0663:  MOVF   7A,W
0664:  ADDWF  6C,F
....................       ++sc;  
0665:  INCF   68,F
....................       sd=memchr(digits,tolower(*sc),base);  
0666:  MOVF   68,W
0667:  MOVWF  04
0668:  MOVF   00,W
0669:  MOVWF  6E
066A:  SUBLW  40
066B:  BTFSC  03.0
066C:  GOTO   674
066D:  MOVF   6E,W
066E:  SUBLW  5A
066F:  BTFSS  03.0
0670:  GOTO   674
0671:  MOVF   6E,W
0672:  IORLW  20
0673:  GOTO   675
0674:  MOVF   6E,W
0675:  MOVWF  6F
0676:  MOVLW  A0
0677:  BSF    03.5
0678:  MOVWF  46
0679:  BCF    03.5
067A:  MOVF   6E,W
067B:  BSF    03.5
067C:  MOVWF  47
067D:  BCF    03.5
067E:  MOVF   67,W
067F:  BSF    03.5
0680:  MOVWF  48
0681:  BCF    03.5
0682:  CALL   4FE
0683:  MOVF   78,W
0684:  MOVWF  6A
....................    }  
0685:  GOTO   63E
....................    if(s1==sc)  
0686:  MOVF   68,W
0687:  SUBWF  69,W
0688:  BTFSS  03.2
0689:  GOTO   695
....................    {  
....................       if (endptr)  
068A:  MOVF   66,F
068B:  BTFSC  03.2
068C:  GOTO   691
....................       {  
....................         *((char *)endptr)=s;  
068D:  MOVF   66,W
068E:  MOVWF  04
068F:  MOVF   65,W
0690:  MOVWF  00
....................       }  
....................    return 0;  
0691:  MOVLW  00
0692:  MOVWF  78
0693:  MOVWF  79
0694:  GOTO   6A9
....................    }  
....................    if(sign=='-')  
0695:  MOVF   6D,W
0696:  SUBLW  2D
0697:  BTFSS  03.2
0698:  GOTO   69E
....................       x  =-x;  
0699:  COMF   6B,F
069A:  COMF   6C,F
069B:  INCF   6B,F
069C:  BTFSC  03.2
069D:  INCF   6C,F
....................    if (endptr)  
069E:  MOVF   66,F
069F:  BTFSC  03.2
06A0:  GOTO   6A5
....................         *((char *)endptr)=sc;  
06A1:  MOVF   66,W
06A2:  MOVWF  04
06A3:  MOVF   68,W
06A4:  MOVWF  00
....................    return x;  
06A5:  MOVF   6B,W
06A6:  MOVWF  78
06A7:  MOVF   6C,W
06A8:  MOVWF  79
.................... }  
06A9:  RETLW  00
....................   
.................... signed int system(char *string)  
.................... {  
....................    return 0;  
.................... }  
....................   
.................... int mblen(char *s,size_t n)  
.................... {  
....................    return strlen(s);  
.................... }  
....................   
.................... int mbtowc(wchar_t *pwc,char *s,size_t n)  
.................... {  
....................    *pwc=*s;  
....................    return 1;  
.................... }  
....................   
.................... int wctomb(char *s,wchar_t wchar)  
.................... {  
....................    *s=wchar;  
....................    return 1;  
.................... }  
....................   
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)  
.................... {  
....................    strncpy(pwcs,s,n);  
....................    return strlen(pwcs);  
.................... }  
....................   
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)  
.................... {  
....................    strncpy(s,pwcs,n);  
....................    return strlen(s);  
.................... }  
....................  
.................... //Arquivo de definição das funcoes auxiliares do programa do controlador  
.................... #include <funcoes.h> 
....................  /*******************************************************************************  
.................... *                         FUNCOES AUXILIARES DO PROGRAMA                       *  
.................... *******************************************************************************/  
....................   
.................... /***** Funcao de ajuste da hora *******/  
....................   
.................... void arruma_hora()  
.................... {  
....................    boolean flag=0;  
*
118A:  BCF    57.0
....................    int8 num=0, time[5],limit[5],pos[5];  
118B:  CLRF   58
....................    date_time_t dat;  
....................   
....................    limpa_lcd();  
118C:  BCF    0A.4
118D:  CALL   0D8
118E:  BSF    0A.4
....................    printf(escreve_lcd,"Ajuste da Hora");  
118F:  CLRF   6F
1190:  MOVF   6F,W
1191:  BCF    0A.4
1192:  CALL   004
1193:  BSF    0A.4
1194:  INCF   6F,F
1195:  MOVWF  77
1196:  MOVWF  72
1197:  BCF    0A.4
1198:  CALL   215
1199:  BSF    0A.4
119A:  MOVLW  0E
119B:  SUBWF  6F,W
119C:  BTFSS  03.2
119D:  GOTO   190
....................   
....................    //Tira o repique da tecla de funcao  
....................    delay_ms(1000);  
119E:  MOVLW  04
119F:  MOVWF  6F
11A0:  MOVLW  FA
11A1:  MOVWF  70
11A2:  BCF    0A.4
11A3:  CALL   075
11A4:  BSF    0A.4
11A5:  DECFSZ 6F,F
11A6:  GOTO   1A0
....................   
....................    //Faz a leitura do RTC para pegar a hora,minuto,segundo  
....................    PCF8583_read_datetime(&dat);  
11A7:  MOVLW  68
11A8:  MOVWF  6F
11A9:  BCF    0A.4
11AA:  BSF    0A.3
11AB:  CALL   246
11AC:  BSF    0A.4
11AD:  BCF    0A.3
....................   
....................    //Escreve a hora do RTC na tela de LCD  
....................    lcd_pos_xy(2,2);  
11AE:  MOVLW  02
11AF:  MOVWF  71
11B0:  MOVWF  72
11B1:  BCF    0A.4
11B2:  CALL   21B
11B3:  BSF    0A.4
....................    printf(escreve_lcd,"%02u:%02u %02u/%02u/%02u",dat.hours,dat.minutes,dat.day,dat.month,dat.year);  
11B4:  MOVF   6A,W
11B5:  MOVWF  70
11B6:  MOVLW  01
11B7:  MOVWF  71
11B8:  BCF    0A.4
11B9:  CALL   7B0
11BA:  BSF    0A.4
11BB:  MOVLW  3A
11BC:  MOVWF  72
11BD:  BCF    0A.4
11BE:  CALL   215
11BF:  BSF    0A.4
11C0:  MOVF   69,W
11C1:  MOVWF  70
11C2:  MOVLW  01
11C3:  MOVWF  71
11C4:  BCF    0A.4
11C5:  CALL   7B0
11C6:  BSF    0A.4
11C7:  MOVLW  20
11C8:  MOVWF  72
11C9:  BCF    0A.4
11CA:  CALL   215
11CB:  BSF    0A.4
11CC:  MOVF   6B,W
11CD:  MOVWF  70
11CE:  MOVLW  01
11CF:  MOVWF  71
11D0:  BCF    0A.4
11D1:  CALL   7B0
11D2:  BSF    0A.4
11D3:  MOVLW  2F
11D4:  MOVWF  72
11D5:  BCF    0A.4
11D6:  CALL   215
11D7:  BSF    0A.4
11D8:  MOVF   6C,W
11D9:  MOVWF  70
11DA:  MOVLW  01
11DB:  MOVWF  71
11DC:  BCF    0A.4
11DD:  CALL   7B0
11DE:  BSF    0A.4
11DF:  MOVLW  2F
11E0:  MOVWF  72
11E1:  BCF    0A.4
11E2:  CALL   215
11E3:  BSF    0A.4
11E4:  MOVF   6D,W
11E5:  MOVWF  70
11E6:  MOVLW  01
11E7:  MOVWF  71
11E8:  BCF    0A.4
11E9:  CALL   7B0
11EA:  BSF    0A.4
....................    // 00:00 99/99  
....................   
....................    //Iguala o valor, com o valor lido  
....................    time[0]=dat.hours;  
11EB:  MOVF   6A,W
11EC:  MOVWF  59
....................    time[1]=dat.minutes;  
11ED:  MOVF   69,W
11EE:  MOVWF  5A
....................    time[2]=dat.day;  
11EF:  MOVF   6B,W
11F0:  MOVWF  5B
....................    time[3]=dat.month;  
11F1:  MOVF   6C,W
11F2:  MOVWF  5C
....................    time[4]=dat.year;  
11F3:  MOVF   6D,W
11F4:  MOVWF  5D
....................   
....................    //limita cada posição ao seu valor maximo  
....................    limit[0]=23;   //Horas  
11F5:  MOVLW  17
11F6:  MOVWF  5E
....................    limit[1]=59;   //Minutos  
11F7:  MOVLW  3B
11F8:  MOVWF  5F
....................    limit[2]=31;   //Dias  
11F9:  MOVLW  1F
11FA:  MOVWF  60
....................    limit[3]=12;   //Meses  
11FB:  MOVLW  0C
11FC:  MOVWF  61
....................    limit[4]=15;   //Ano  
11FD:  MOVLW  0F
11FE:  MOVWF  62
....................   
....................    //Define a posicão no LCD  
....................    pos[0]=2;   //Hora  
11FF:  MOVLW  02
1200:  MOVWF  63
....................    pos[1]=5;   //Minuto  
1201:  MOVLW  05
1202:  MOVWF  64
....................    pos[2]=8;   //Dia  
1203:  MOVLW  08
1204:  MOVWF  65
....................    pos[3]=11;  //Mes  
1205:  MOVLW  0B
1206:  MOVWF  66
....................    pos[4]=14;  //Ano  
1207:  MOVLW  0E
1208:  MOVWF  67
....................   
....................    //Até que todos os digitos estejam certos ( hh:mm dd/mm )  
....................    while (num<=4)  
....................    {  
1209:  MOVF   58,W
120A:  SUBLW  04
120B:  BTFSS  03.0
120C:  GOTO   26D
....................        //para indicar quem está sendo ajustado no momento  
....................        lcd_pos_xy(pos[num]-1,2);  
120D:  MOVLW  63
120E:  ADDWF  58,W
120F:  MOVWF  04
1210:  MOVLW  01
1211:  SUBWF  00,W
1212:  MOVWF  70
1213:  MOVWF  71
1214:  MOVLW  02
1215:  MOVWF  72
1216:  BCF    0A.4
1217:  CALL   21B
1218:  BSF    0A.4
....................        printf(escreve_lcd,"%c",0x7E);  //Setinha  
1219:  MOVLW  7E
121A:  MOVWF  72
121B:  BCF    0A.4
121C:  CALL   215
121D:  BSF    0A.4
....................   
....................        if (tecla2) {  
121E:  BSF    37.3
121F:  MOVF   37,W
1220:  BSF    03.5
1221:  MOVWF  07
1222:  BCF    03.5
1223:  BTFSC  07.3
1224:  GOTO   25B
*
1811:  MOVLW  FF
1812:  MOVWF  37
....................             //Soma um ao dígito atual  
....................             time[num]++;  
*
1225:  MOVLW  59
1226:  ADDWF  58,W
1227:  MOVWF  04
1228:  INCF   00,F
....................             if (time[num]>limit[num])  
1229:  MOVLW  59
122A:  ADDWF  58,W
122B:  MOVWF  04
122C:  MOVF   00,W
122D:  MOVWF  6F
122E:  MOVLW  5E
122F:  ADDWF  58,W
1230:  MOVWF  04
1231:  MOVF   00,W
1232:  SUBWF  6F,W
1233:  BTFSC  03.2
1234:  GOTO   23C
1235:  BTFSS  03.0
1236:  GOTO   23C
....................             {  
....................                time[num]=01;  
1237:  MOVLW  59
1238:  ADDWF  58,W
1239:  MOVWF  04
123A:  MOVLW  01
123B:  MOVWF  00
....................             }  
....................             //Mostra no LCD  
....................             lcd_pos_xy(pos[num],2);  
123C:  MOVLW  63
123D:  ADDWF  58,W
123E:  MOVWF  04
123F:  MOVF   00,W
1240:  MOVWF  6F
1241:  MOVWF  71
1242:  MOVLW  02
1243:  MOVWF  72
1244:  BCF    0A.4
1245:  CALL   21B
1246:  BSF    0A.4
....................             printf(escreve_lcd,"%02u",time[num]);  
1247:  MOVLW  59
1248:  ADDWF  58,W
1249:  MOVWF  04
124A:  MOVF   00,W
124B:  MOVWF  6F
124C:  MOVWF  70
124D:  MOVLW  01
124E:  MOVWF  71
124F:  BCF    0A.4
1250:  CALL   7B0
1251:  BSF    0A.4
....................   
....................             //Tira o repique e evita erros  
....................             delay_ms(500);  
1252:  MOVLW  02
1253:  MOVWF  6F
1254:  MOVLW  FA
1255:  MOVWF  70
1256:  BCF    0A.4
1257:  CALL   075
1258:  BSF    0A.4
1259:  DECFSZ 6F,F
125A:  GOTO   254
....................        }  
....................        if (tecla1) {  
125B:  BSF    37.2
125C:  MOVF   37,W
125D:  BSF    03.5
125E:  MOVWF  07
125F:  BCF    03.5
1260:  BTFSC  07.2
1261:  GOTO   26C
....................             //Passa ao proximo numero a ser acertado  
....................             num++;  
1262:  INCF   58,F
....................             //Tira o repique  
....................             delay_ms(500);  
1263:  MOVLW  02
1264:  MOVWF  6F
1265:  MOVLW  FA
1266:  MOVWF  70
1267:  BCF    0A.4
1268:  CALL   075
1269:  BSF    0A.4
126A:  DECFSZ 6F,F
126B:  GOTO   265
....................        }  
....................    }  
126C:  GOTO   209
....................   
....................    dat.month   = time[3];   // Mês  
126D:  MOVF   5C,W
126E:  MOVWF  6C
....................    dat.day     = time[2];   // Dia  
126F:  MOVF   5B,W
1270:  MOVWF  6B
....................    dat.year    = time[4];   // Ano  
1271:  MOVF   5D,W
1272:  MOVWF  6D
....................    dat.hours   = time[0];   // Horas  
1273:  MOVF   59,W
1274:  MOVWF  6A
....................    dat.minutes = time[1];   // Minutos  
1275:  MOVF   5A,W
1276:  MOVWF  69
....................    dat.seconds = 00;        // Segundos  
1277:  CLRF   68
....................    dat.weekday = 3;         // 0 = Sunday, 1 = Monday, etc.  
1278:  MOVLW  03
1279:  MOVWF  6E
....................   
....................    //Ajusta o relogio definitivamente  
....................    PCF8583_set_datetime(&dat);  
127A:  MOVLW  68
127B:  MOVWF  6F
....................   
....................    limpa_lcd();  
*
133F:  BCF    0A.4
1340:  CALL   0D8
1341:  BSF    0A.4
....................   
.................... }  
1342:  BSF    0A.3
1343:  BSF    0A.4
1344:  GOTO   58D (RETURN)
....................   
.................... /***** Funcao que mostra a máxima e mínima *******/  
....................   
.................... void Max_Min()  
.................... {  
....................    //Le os valores de max e min na eeprom  
....................    limpa_lcd();  
1345:  BCF    0A.4
1346:  CALL   0D8
1347:  BSF    0A.4
....................    // Escreve a Temperatura Máxima  
....................    //                  + 30.1 22/11 14h  
....................    printf(escreve_lcd,"+%2.1f %02u/%02u %02uh",read_float_eeprom(1),  
....................                                   read_eeprom(7),read_eeprom(8),read_eeprom(5));  
1348:  MOVLW  01
1349:  MOVWF  57
134A:  BCF    0A.4
134B:  CALL   2A6
134C:  BSF    0A.4
134D:  MOVF   77,W
134E:  MOVWF  57
134F:  MOVF   78,W
1350:  MOVWF  58
1351:  MOVF   79,W
1352:  MOVWF  59
1353:  MOVF   7A,W
1354:  MOVWF  5A
1355:  BSF    03.6
1356:  CLRF   0E
1357:  MOVLW  07
1358:  MOVWF  0D
1359:  BSF    03.5
135A:  BCF    0C.7
135B:  BSF    0C.0
135C:  BCF    03.5
135D:  MOVF   0C,W
135E:  BCF    03.6
135F:  MOVWF  5B
1360:  BSF    03.6
1361:  CLRF   0E
1362:  MOVLW  08
1363:  MOVWF  0D
1364:  BSF    03.5
1365:  BCF    0C.7
1366:  BSF    0C.0
1367:  BCF    03.5
1368:  MOVF   0C,W
1369:  BCF    03.6
136A:  MOVWF  5C
136B:  BSF    03.6
136C:  CLRF   0E
136D:  MOVLW  05
136E:  MOVWF  0D
136F:  BSF    03.5
1370:  BCF    0C.7
1371:  BSF    0C.0
1372:  BCF    03.5
1373:  MOVF   0C,W
1374:  BCF    03.6
1375:  MOVWF  5D
1376:  MOVLW  2B
1377:  MOVWF  72
1378:  BCF    0A.4
1379:  CALL   215
137A:  BSF    0A.4
137B:  MOVF   5A,W
137C:  MOVWF  61
137D:  MOVF   59,W
137E:  MOVWF  60
137F:  MOVF   58,W
1380:  MOVWF  5F
1381:  MOVF   57,W
1382:  MOVWF  5E
1383:  CLRF   65
1384:  CLRF   64
1385:  MOVLW  01
1386:  MOVWF  63
1387:  MOVWF  62
1388:  BCF    0A.4
1389:  BSF    0A.3
138A:  CALL   359
138B:  BSF    0A.4
138C:  BCF    0A.3
138D:  MOVLW  20
138E:  MOVWF  72
138F:  BCF    0A.4
1390:  CALL   215
1391:  BSF    0A.4
1392:  MOVF   5B,W
1393:  MOVWF  70
1394:  MOVLW  01
1395:  MOVWF  71
1396:  BCF    0A.4
1397:  CALL   7B0
1398:  BSF    0A.4
1399:  MOVLW  2F
139A:  MOVWF  72
139B:  BCF    0A.4
139C:  CALL   215
139D:  BSF    0A.4
139E:  MOVF   5C,W
139F:  MOVWF  70
13A0:  MOVLW  01
13A1:  MOVWF  71
13A2:  BCF    0A.4
13A3:  CALL   7B0
13A4:  BSF    0A.4
13A5:  MOVLW  20
13A6:  MOVWF  72
13A7:  BCF    0A.4
13A8:  CALL   215
13A9:  BSF    0A.4
13AA:  MOVF   5D,W
13AB:  MOVWF  70
13AC:  MOVLW  01
13AD:  MOVWF  71
13AE:  BCF    0A.4
13AF:  CALL   7B0
13B0:  BSF    0A.4
13B1:  MOVLW  68
13B2:  MOVWF  72
13B3:  BCF    0A.4
13B4:  CALL   215
13B5:  BSF    0A.4
....................    // Escreve a Temperatura Mínima  
....................    lcd_pos_xy(1,2);  
13B6:  MOVLW  01
13B7:  MOVWF  71
13B8:  MOVLW  02
13B9:  MOVWF  72
13BA:  BCF    0A.4
13BB:  CALL   21B
13BC:  BSF    0A.4
....................    printf(escreve_lcd,"-%2.1f %02u/%02u %02uh",read_float_eeprom(9),  
....................                                   read_eeprom(15),read_eeprom(16),read_eeprom(13));  
13BD:  MOVLW  09
13BE:  MOVWF  57
13BF:  BCF    0A.4
13C0:  CALL   2A6
13C1:  BSF    0A.4
13C2:  MOVF   77,W
13C3:  MOVWF  57
13C4:  MOVF   78,W
13C5:  MOVWF  58
13C6:  MOVF   79,W
13C7:  MOVWF  59
13C8:  MOVF   7A,W
13C9:  MOVWF  5A
13CA:  BSF    03.6
13CB:  CLRF   0E
13CC:  MOVLW  0F
13CD:  MOVWF  0D
13CE:  BSF    03.5
13CF:  BCF    0C.7
13D0:  BSF    0C.0
13D1:  BCF    03.5
13D2:  MOVF   0C,W
13D3:  BCF    03.6
13D4:  MOVWF  5B
13D5:  BSF    03.6
13D6:  CLRF   0E
13D7:  MOVLW  10
13D8:  MOVWF  0D
13D9:  BSF    03.5
13DA:  BCF    0C.7
13DB:  BSF    0C.0
13DC:  BCF    03.5
13DD:  MOVF   0C,W
13DE:  BCF    03.6
13DF:  MOVWF  5C
13E0:  BSF    03.6
13E1:  CLRF   0E
13E2:  MOVLW  0D
13E3:  MOVWF  0D
13E4:  BSF    03.5
13E5:  BCF    0C.7
13E6:  BSF    0C.0
13E7:  BCF    03.5
13E8:  MOVF   0C,W
13E9:  BCF    03.6
13EA:  MOVWF  5D
13EB:  MOVLW  2D
13EC:  MOVWF  72
13ED:  BCF    0A.4
13EE:  CALL   215
13EF:  BSF    0A.4
13F0:  MOVF   5A,W
13F1:  MOVWF  61
13F2:  MOVF   59,W
13F3:  MOVWF  60
13F4:  MOVF   58,W
13F5:  MOVWF  5F
13F6:  MOVF   57,W
13F7:  MOVWF  5E
13F8:  CLRF   65
13F9:  CLRF   64
13FA:  MOVLW  01
13FB:  MOVWF  63
13FC:  MOVWF  62
13FD:  BCF    0A.4
13FE:  BSF    0A.3
13FF:  CALL   359
1400:  BSF    0A.4
1401:  BCF    0A.3
1402:  MOVLW  20
1403:  MOVWF  72
1404:  BCF    0A.4
1405:  CALL   215
1406:  BSF    0A.4
1407:  MOVF   5B,W
1408:  MOVWF  70
1409:  MOVLW  01
140A:  MOVWF  71
140B:  BCF    0A.4
140C:  CALL   7B0
140D:  BSF    0A.4
140E:  MOVLW  2F
140F:  MOVWF  72
1410:  BCF    0A.4
1411:  CALL   215
1412:  BSF    0A.4
1413:  MOVF   5C,W
1414:  MOVWF  70
1415:  MOVLW  01
1416:  MOVWF  71
1417:  BCF    0A.4
1418:  CALL   7B0
1419:  BSF    0A.4
141A:  MOVLW  20
141B:  MOVWF  72
141C:  BCF    0A.4
141D:  CALL   215
141E:  BSF    0A.4
141F:  MOVF   5D,W
1420:  MOVWF  70
1421:  MOVLW  01
1422:  MOVWF  71
1423:  BCF    0A.4
1424:  CALL   7B0
1425:  BSF    0A.4
1426:  MOVLW  68
1427:  MOVWF  72
1428:  BCF    0A.4
1429:  CALL   215
142A:  BSF    0A.4
....................    //Aguarda 5 Segundos  
....................    delay_ms(5000);  
142B:  MOVLW  14
142C:  MOVWF  57
142D:  MOVLW  FA
142E:  MOVWF  70
142F:  BCF    0A.4
1430:  CALL   075
1431:  BSF    0A.4
1432:  DECFSZ 57,F
1433:  GOTO   42D
....................    //Limpa o LCD  
....................    limpa_lcd();  
1434:  BCF    0A.4
1435:  CALL   0D8
1436:  BSF    0A.4
....................    //Volta  
....................    return;  
.................... }  
1437:  BSF    0A.3
1438:  BSF    0A.4
1439:  GOTO   597 (RETURN)
....................   
.................... /***** Funcao de tratamento serial *******/  
....................   
.................... /******************************************************************************  
.................... *  Comunicacao serial com o computador                                        *  
.................... *  L        - Devolve os dados de Temperatura e Umidade para os dias          *  
.................... *             No formato dd/mm ttt uuu                                        *  
.................... *  R        - Reseta a EEPROM externa zerando seus dados                      *  
.................... *  C        - Recebe uma String Assim CM:00:12:01:15#                         *  
.................... *              Significa que Grava na Posição 01                              *  
.................... *                                    Ligar as 12 Horas                        *  
.................... *                                             01 Minutos                      *  
.................... *                             Fica ligado por 15 Segundos                     *  
.................... ******************************************************************************/  
....................   
.................... void trata_serial(){  
....................    signed long i=0,EEPos,Hora,Minuto,Tempo;  
*
0800:  CLRF   57
0801:  CLRF   58
....................    int pos;  
....................    char *ptr,tmp[2];  
....................   
....................    //Se for pressionado o "L" - Le as temperaturas e devolve  
....................    if (Buffer[0] =='l')  
0802:  MOVF   22,W
0803:  SUBLW  6C
0804:  BTFSS  03.2
0805:  GOTO   0BE
....................    {  
....................       i=0;  
0806:  CLRF   58
0807:  CLRF   57
....................       while(i<mem_pos)  
....................       {  
0808:  BTFSS  58.7
0809:  GOTO   00D
080A:  BTFSS  21.7
080B:  GOTO   019
080C:  GOTO   00F
080D:  BTFSC  21.7
080E:  GOTO   0BE
080F:  MOVF   58,W
0810:  SUBWF  21,W
0811:  BTFSS  03.0
0812:  GOTO   0BE
0813:  BTFSS  03.2
0814:  GOTO   019
0815:  MOVF   20,W
0816:  SUBWF  57,W
0817:  BTFSC  03.0
0818:  GOTO   0BE
....................          //Dia  
....................          printf("%02u/",le_eeprom(0,i));  
0819:  CLRF   6C
081A:  MOVF   58,W
081B:  MOVWF  6E
081C:  MOVF   57,W
081D:  MOVWF  6D
081E:  BCF    0A.3
081F:  CALL   2FA
0820:  BSF    0A.3
0821:  MOVF   78,W
0822:  MOVWF  65
0823:  MOVWF  66
0824:  MOVLW  01
0825:  MOVWF  67
0826:  BCF    0A.3
0827:  CALL   387
0828:  BSF    0A.3
0829:  MOVLW  2F
082A:  BTFSS  0C.4
082B:  GOTO   02A
082C:  MOVWF  19
....................          i++;  
082D:  INCF   57,F
082E:  BTFSC  03.2
082F:  INCF   58,F
....................          //Mes  
....................          printf("%02u ",le_eeprom(0,i));  
0830:  CLRF   6C
0831:  MOVF   58,W
0832:  MOVWF  6E
0833:  MOVF   57,W
0834:  MOVWF  6D
0835:  BCF    0A.3
0836:  CALL   2FA
0837:  BSF    0A.3
0838:  MOVF   78,W
0839:  MOVWF  65
083A:  MOVWF  66
083B:  MOVLW  01
083C:  MOVWF  67
083D:  BCF    0A.3
083E:  CALL   387
083F:  BSF    0A.3
0840:  MOVLW  20
0841:  BTFSS  0C.4
0842:  GOTO   041
0843:  MOVWF  19
....................          i++;  
0844:  INCF   57,F
0845:  BTFSC  03.2
0846:  INCF   58,F
....................          //Hora  
....................          printf("%02u ",le_eeprom(0,i));  
0847:  CLRF   6C
0848:  MOVF   58,W
0849:  MOVWF  6E
084A:  MOVF   57,W
084B:  MOVWF  6D
084C:  BCF    0A.3
084D:  CALL   2FA
084E:  BSF    0A.3
084F:  MOVF   78,W
0850:  MOVWF  65
0851:  MOVWF  66
0852:  MOVLW  01
0853:  MOVWF  67
0854:  BCF    0A.3
0855:  CALL   387
0856:  BSF    0A.3
0857:  MOVLW  20
0858:  BTFSS  0C.4
0859:  GOTO   058
085A:  MOVWF  19
....................          i++;  
085B:  INCF   57,F
085C:  BTFSC  03.2
085D:  INCF   58,F
....................          //Umidade  
....................          printf("%03u ",le_eeprom(0,i));  
085E:  CLRF   6C
085F:  MOVF   58,W
0860:  MOVWF  6E
0861:  MOVF   57,W
0862:  MOVWF  6D
0863:  BCF    0A.3
0864:  CALL   2FA
0865:  BSF    0A.3
0866:  MOVF   78,W
0867:  MOVWF  65
0868:  MOVWF  66
0869:  CLRF   67
086A:  BCF    0A.3
086B:  CALL   387
086C:  BSF    0A.3
086D:  MOVLW  20
086E:  BTFSS  0C.4
086F:  GOTO   06E
0870:  MOVWF  19
....................          i++;  
0871:  INCF   57,F
0872:  BTFSC  03.2
0873:  INCF   58,F
....................          //Temperatura e fim de linha  
....................          printf("%lu\n\r",le_eeprom_16(0,i));  
0874:  CLRF   65
0875:  MOVF   58,W
0876:  MOVWF  67
0877:  MOVF   57,W
0878:  MOVWF  66
*
089D:  MOVF   79,W
089E:  MOVWF  66
089F:  MOVF   78,W
08A0:  MOVWF  65
08A1:  MOVLW  10
08A2:  MOVWF  04
08A3:  MOVF   66,W
08A4:  MOVWF  68
08A5:  MOVF   65,W
08A6:  MOVWF  67
08A7:  BCF    0A.3
08A8:  GOTO   3BC
08A9:  BSF    0A.3
08AA:  MOVLW  0A
08AB:  BTFSS  0C.4
08AC:  GOTO   0AB
08AD:  MOVWF  19
08AE:  MOVLW  0D
08AF:  BTFSS  0C.4
08B0:  GOTO   0AF
08B1:  MOVWF  19
....................          i++;  
08B2:  INCF   57,F
08B3:  BTFSC  03.2
08B4:  INCF   58,F
....................          i++;  
08B5:  INCF   57,F
08B6:  BTFSC  03.2
08B7:  INCF   58,F
....................          //Tempo de espera só para evitar erros de envio  
....................          delay_ms(2);  
08B8:  MOVLW  02
08B9:  MOVWF  70
08BA:  BCF    0A.3
08BB:  CALL   075
08BC:  BSF    0A.3
....................       }  
08BD:  GOTO   008
....................    }  
....................    // Rotina que "formata" a EEPROM externa zerando todos valores  
....................    if (Buffer[0] == 'r'){  
08BE:  MOVF   22,W
08BF:  SUBLW  72
08C0:  BTFSS  03.2
08C1:  GOTO   12F
....................       pos=1;  
08C2:  MOVLW  01
08C3:  MOVWF  61
....................       limpa_lcd();  
08C4:  BCF    0A.3
08C5:  CALL   0D8
08C6:  BSF    0A.3
....................       printf(escreve_lcd,"    Aguarde");  
08C7:  MOVLW  04
08C8:  MOVWF  65
08C9:  MOVLW  20
08CA:  MOVWF  72
08CB:  BCF    0A.3
08CC:  CALL   215
08CD:  BSF    0A.3
08CE:  DECFSZ 65,F
08CF:  GOTO   0C9
08D0:  CLRF   66
08D1:  MOVF   66,W
08D2:  BCF    0A.3
08D3:  CALL   017
08D4:  BSF    0A.3
08D5:  INCF   66,F
08D6:  MOVWF  77
08D7:  MOVWF  72
08D8:  BCF    0A.3
08D9:  CALL   215
08DA:  BSF    0A.3
08DB:  MOVLW  07
08DC:  SUBWF  66,W
08DD:  BTFSS  03.2
08DE:  GOTO   0D1
....................       for(i=0;i<8191;i++){  
08DF:  CLRF   58
08E0:  CLRF   57
08E1:  BTFSC  58.7
08E2:  GOTO   0ED
08E3:  MOVF   58,W
08E4:  SUBLW  1F
08E5:  BTFSS  03.0
08E6:  GOTO   114
08E7:  BTFSS  03.2
08E8:  GOTO   0ED
08E9:  MOVF   57,W
08EA:  SUBLW  FE
08EB:  BTFSS  03.0
08EC:  GOTO   114
....................          // Escreve o valor 0 na EEPROM no endereco i  
....................          escreve_eeprom(0,i,0x00);  
08ED:  CLRF   65
08EE:  MOVF   58,W
08EF:  MOVWF  67
08F0:  MOVF   57,W
08F1:  MOVWF  66
08F2:  CLRF   68
08F3:  BCF    0A.3
08F4:  CALL   44F
08F5:  BSF    0A.3
....................          // A cada 512 valores Atualiza um grafico de progresso  
....................          if (!(i % 512)){  
08F6:  MOVF   58,W
08F7:  MOVWF  66
08F8:  MOVF   57,W
08F9:  MOVWF  65
08FA:  MOVLW  02
08FB:  MOVWF  68
08FC:  CLRF   67
08FD:  BCF    0A.3
08FE:  GOTO   4BD
08FF:  BSF    0A.3
0900:  MOVF   77,W
0901:  IORWF  7A,W
0902:  BTFSS  03.2
0903:  GOTO   110
....................             lcd_pos_xy(pos,2);  
0904:  MOVF   61,W
0905:  MOVWF  71
0906:  MOVLW  02
0907:  MOVWF  72
0908:  BCF    0A.3
0909:  CALL   21B
090A:  BSF    0A.3
....................             //Escreve o caractere ">" para indicar o progresso  
....................             escreve_lcd(0x00);  
090B:  CLRF   72
090C:  BCF    0A.3
090D:  CALL   215
090E:  BSF    0A.3
....................             pos++;  
090F:  INCF   61,F
....................          }  
....................       }  
0910:  INCF   57,F
0911:  BTFSC  03.2
0912:  INCF   58,F
0913:  GOTO   0E1
....................       limpa_lcd();  
0914:  BCF    0A.3
0915:  CALL   0D8
0916:  BSF    0A.3
....................       // Retorna um OK via serial para indicar o encerramento da tranmisao  
....................       printf("OK\n\r");  
0917:  CLRF   65
0918:  MOVF   65,W
0919:  BCF    0A.3
091A:  CALL   023
091B:  BSF    0A.3
091C:  INCF   65,F
091D:  MOVWF  77
091E:  MOVF   77,W
091F:  BTFSS  0C.4
0920:  GOTO   11F
0921:  MOVWF  19
0922:  MOVLW  04
0923:  SUBWF  65,W
0924:  BTFSS  03.2
0925:  GOTO   118
....................       //Atualiza o endereco na EEPROM interna  
....................       write_eeprom_16(17,0x00);  
0926:  MOVLW  11
0927:  MOVWF  65
0928:  CLRF   67
0929:  CLRF   66
092A:  BCF    0A.3
092B:  CALL   25A
092C:  BSF    0A.3
....................       //Zera a variavel de posicao  
....................       mem_pos=0;  
092D:  CLRF   21
092E:  CLRF   20
....................    }  
....................    if (Buffer[0] == 'C'){  
092F:  MOVF   22,W
0930:  SUBLW  43
0931:  BTFSS  03.2
0932:  GOTO   243
....................   
....................       //Recebe uma String Assim CM:00:12:01:15#  
....................       // Significa que Grava na Posição 01  
....................       //                       Ligar as 12 Horas  
....................       //                                01 Minutos  
....................       //                Fica ligado por 15 Segundos  
....................   
....................       //Separa os tempos  
....................       //Separa os dois primeiros caracteres  
....................       tmp[0]=Buffer[3];  
0933:  MOVF   25,W
0934:  MOVWF  63
....................       tmp[1]=Buffer[4];  
0935:  MOVF   26,W
0936:  MOVWF  64
....................       //Converte o valor em Long  
....................       EEPos  = strtol(tmp,&ptr,10);  
0937:  MOVLW  63
0938:  MOVWF  65
0939:  MOVLW  62
093A:  MOVWF  66
093B:  MOVLW  0A
093C:  MOVWF  67
093D:  BCF    0A.3
093E:  CALL   530
093F:  BSF    0A.3
0940:  MOVF   79,W
0941:  MOVWF  5A
0942:  MOVF   78,W
0943:  MOVWF  59
....................   
....................       //Continua separando  
....................       tmp[0]=Buffer[6];  
0944:  MOVF   28,W
0945:  MOVWF  63
....................       tmp[1]=Buffer[7];  
0946:  MOVF   29,W
0947:  MOVWF  64
....................       //Converte o valor em Long  
....................       Hora   = strtol(tmp,&ptr,10);  
0948:  MOVLW  63
0949:  MOVWF  65
094A:  MOVLW  62
094B:  MOVWF  66
094C:  MOVLW  0A
094D:  MOVWF  67
094E:  BCF    0A.3
094F:  CALL   530
0950:  BSF    0A.3
0951:  MOVF   79,W
0952:  MOVWF  5C
0953:  MOVF   78,W
0954:  MOVWF  5B
....................   
....................       tmp[0]=Buffer[9];  
0955:  MOVF   2B,W
0956:  MOVWF  63
....................       tmp[1]=Buffer[10];  
0957:  MOVF   2C,W
0958:  MOVWF  64
....................       //Converte o valor em Long  
....................       Minuto = strtol(tmp,&ptr,10);  
0959:  MOVLW  63
095A:  MOVWF  65
095B:  MOVLW  62
095C:  MOVWF  66
095D:  MOVLW  0A
095E:  MOVWF  67
095F:  BCF    0A.3
0960:  CALL   530
0961:  BSF    0A.3
0962:  MOVF   79,W
0963:  MOVWF  5E
0964:  MOVF   78,W
0965:  MOVWF  5D
....................   
....................       tmp[0]=Buffer[12];  
0966:  MOVF   2E,W
0967:  MOVWF  63
....................       tmp[1]=Buffer[13];  
0968:  MOVF   2F,W
0969:  MOVWF  64
....................       //Converte o valor em Long  
....................       Tempo  = strtol(tmp,&ptr,10);  
096A:  MOVLW  63
096B:  MOVWF  65
096C:  MOVLW  62
096D:  MOVWF  66
096E:  MOVLW  0A
096F:  MOVWF  67
0970:  BCF    0A.3
0971:  CALL   530
0972:  BSF    0A.3
0973:  MOVF   79,W
0974:  MOVWF  60
0975:  MOVF   78,W
0976:  MOVWF  5F
....................   
....................       //Calcula a posição na EEprom interna  
....................       i = 20+((int)EEPos*3);  
0977:  MOVF   59,W
0978:  MOVWF  65
0979:  MOVLW  03
097A:  MOVWF  66
097B:  BCF    0A.3
097C:  CALL   6AA
097D:  BSF    0A.3
097E:  MOVF   78,W
097F:  ADDLW  14
0980:  CLRF   7A
0981:  MOVWF  57
0982:  MOVF   7A,W
0983:  MOVWF  58
....................   
....................       //Escreve na EEprom Interna a Hora  
....................       write_eeprom(i,(int)Hora);  
0984:  MOVF   58,W
0985:  BSF    03.6
0986:  MOVWF  0E
0987:  BCF    03.6
0988:  MOVF   57,W
0989:  BSF    03.6
098A:  MOVWF  0D
098B:  BCF    03.6
098C:  MOVF   5B,W
098D:  BSF    03.6
098E:  MOVWF  0C
098F:  BSF    03.5
0990:  BCF    0C.7
0991:  BSF    0C.2
0992:  BCF    03.5
0993:  BCF    03.6
0994:  MOVF   0B,W
0995:  MOVWF  77
0996:  BCF    0B.7
0997:  BSF    03.5
0998:  BSF    03.6
0999:  MOVLW  55
099A:  MOVWF  0D
099B:  MOVLW  AA
099C:  MOVWF  0D
099D:  BSF    0C.1
099E:  BTFSC  0C.1
099F:  GOTO   19E
09A0:  BCF    0C.2
09A1:  MOVF   77,W
09A2:  BCF    03.5
09A3:  BCF    03.6
09A4:  IORWF  0B,F
....................       i++;  
09A5:  INCF   57,F
09A6:  BTFSC  03.2
09A7:  INCF   58,F
....................       //Escreve na EEprom interna o Minuto  
....................       write_eeprom(i,(int)Minuto);  
09A8:  MOVF   58,W
09A9:  BSF    03.6
09AA:  MOVWF  0E
09AB:  BCF    03.6
09AC:  MOVF   57,W
09AD:  BSF    03.6
09AE:  MOVWF  0D
09AF:  BCF    03.6
09B0:  MOVF   5D,W
09B1:  BSF    03.6
09B2:  MOVWF  0C
09B3:  BSF    03.5
09B4:  BCF    0C.7
09B5:  BSF    0C.2
09B6:  BCF    03.5
09B7:  BCF    03.6
09B8:  MOVF   0B,W
09B9:  MOVWF  77
09BA:  BCF    0B.7
09BB:  BSF    03.5
09BC:  BSF    03.6
09BD:  MOVLW  55
09BE:  MOVWF  0D
09BF:  MOVLW  AA
09C0:  MOVWF  0D
09C1:  BSF    0C.1
09C2:  BTFSC  0C.1
09C3:  GOTO   1C2
09C4:  BCF    0C.2
09C5:  MOVF   77,W
09C6:  BCF    03.5
09C7:  BCF    03.6
09C8:  IORWF  0B,F
....................       i++;  
09C9:  INCF   57,F
09CA:  BTFSC  03.2
09CB:  INCF   58,F
....................       //Escreve na EEprom interna o Tempo Ligado  
....................       write_eeprom(i,(int)Tempo);  
09CC:  MOVF   58,W
09CD:  BSF    03.6
09CE:  MOVWF  0E
09CF:  BCF    03.6
09D0:  MOVF   57,W
09D1:  BSF    03.6
09D2:  MOVWF  0D
09D3:  BCF    03.6
09D4:  MOVF   5F,W
09D5:  BSF    03.6
09D6:  MOVWF  0C
09D7:  BSF    03.5
09D8:  BCF    0C.7
09D9:  BSF    0C.2
09DA:  BCF    03.5
09DB:  BCF    03.6
09DC:  MOVF   0B,W
09DD:  MOVWF  77
09DE:  BCF    0B.7
09DF:  BSF    03.5
09E0:  BSF    03.6
09E1:  MOVLW  55
09E2:  MOVWF  0D
09E3:  MOVLW  AA
09E4:  MOVWF  0D
09E5:  BSF    0C.1
09E6:  BTFSC  0C.1
09E7:  GOTO   1E6
09E8:  BCF    0C.2
09E9:  MOVF   77,W
09EA:  BCF    03.5
09EB:  BCF    03.6
09EC:  IORWF  0B,F
....................   
....................       //Limpa o Buffer para próxima recepção  
....................       printf(escreve_lcd,"%s",Buffer);  
09ED:  MOVLW  22
09EE:  MOVWF  04
09EF:  MOVLW  00
09F0:  IORWF  00,W
09F1:  BTFSC  03.2
09F2:  GOTO   1FE
09F3:  MOVF   04,W
09F4:  MOVWF  65
09F5:  MOVF   00,W
09F6:  MOVWF  72
09F7:  BCF    0A.3
09F8:  CALL   215
09F9:  BSF    0A.3
09FA:  MOVF   65,W
09FB:  MOVWF  04
09FC:  INCF   04,F
09FD:  GOTO   1EF
....................       lcd_pos_xy(1,2);  
09FE:  MOVLW  01
09FF:  MOVWF  71
0A00:  MOVLW  02
0A01:  MOVWF  72
0A02:  BCF    0A.3
0A03:  CALL   21B
0A04:  BSF    0A.3
....................       printf(escreve_lcd,"%2ld%2ld%2ld%2ld",EEpos,Hora,Minuto,Tempo);  
0A05:  MOVLW  03
0A06:  MOVWF  04
0A07:  MOVF   5A,W
0A08:  MOVWF  66
0A09:  MOVF   59,W
0A0A:  MOVWF  65
0A0B:  BCF    0A.3
0A0C:  CALL   6CF
0A0D:  BSF    0A.3
0A0E:  MOVLW  03
0A0F:  MOVWF  04
0A10:  MOVF   5C,W
0A11:  MOVWF  66
0A12:  MOVF   5B,W
0A13:  MOVWF  65
0A14:  BCF    0A.3
0A15:  CALL   6CF
0A16:  BSF    0A.3
0A17:  MOVLW  03
0A18:  MOVWF  04
0A19:  MOVF   5E,W
0A1A:  MOVWF  66
0A1B:  MOVF   5D,W
0A1C:  MOVWF  65
0A1D:  BCF    0A.3
0A1E:  CALL   6CF
0A1F:  BSF    0A.3
0A20:  MOVLW  03
0A21:  MOVWF  04
0A22:  MOVF   60,W
0A23:  MOVWF  66
0A24:  MOVF   5F,W
0A25:  MOVWF  65
0A26:  BCF    0A.3
0A27:  CALL   6CF
0A28:  BSF    0A.3
....................       strcpy(Buffer,"");  
0A29:  CLRF   65
0A2A:  CLRF   66
0A2B:  MOVLW  22
0A2C:  MOVWF  04
0A2D:  MOVF   65,W
0A2E:  ADDWF  04,F
0A2F:  MOVF   66,W
0A30:  BCF    0A.3
0A31:  CALL   02C
0A32:  BSF    0A.3
0A33:  MOVWF  00
0A34:  IORLW  00
0A35:  BTFSC  03.2
0A36:  GOTO   23A
0A37:  INCF   66,F
0A38:  INCF   65,F
0A39:  GOTO   22B
....................       delay_ms(3000);  
0A3A:  MOVLW  0C
0A3B:  MOVWF  65
0A3C:  MOVLW  FA
0A3D:  MOVWF  70
0A3E:  BCF    0A.3
0A3F:  CALL   075
0A40:  BSF    0A.3
0A41:  DECFSZ 65,F
0A42:  GOTO   23C
....................    }  
.................... }  
0A43:  BSF    0A.3
0A44:  BSF    0A.4
0A45:  GOTO   185 (RETURN)
....................  
....................   
.................... /*******************************************************************************  
.................... *                          FUNCAO PRINCIPAL DO PROGRAMA                        *  
.................... *******************************************************************************/  
....................   
....................   
.................... void main()  
.................... {  
*
1800:  CLRF   04
1801:  MOVLW  1F
1802:  ANDWF  03,F
1803:  BSF    03.5
1804:  BSF    1F.0
1805:  BSF    1F.1
1806:  BSF    1F.2
1807:  BCF    1F.3
1808:  MOVLW  19
1809:  MOVWF  19
180A:  MOVLW  26
180B:  MOVWF  18
180C:  MOVLW  90
180D:  BCF    03.5
180E:  MOVWF  18
....................    //Flag de estado do LED  
....................    int1 flag=1,Ftemp=1,Fregistro=1,fBomba=0,fBomba_old=0;  
*
1813:  BSF    38.0
1814:  BSF    38.1
1815:  BSF    38.2
1816:  BCF    38.3
1817:  BCF    38.4
....................    //Variavel de 8 bits para teste  
....................    int8 conta,a,pos;  
....................    //Variavel de 16 bits para teste  
....................    long i=0,Temp_16;//,Humi_16 /*,T1,T2 */;  
1818:  CLRF   3C
1819:  CLRF   3D
....................    //Variavel de ponto flutuante para armazenar as temperaturas/pt. de orvalho  
....................    float Temp,T_Max,T_Min,RH /*,dew_point,T_Temp*/ ;  
....................    //Variavel tipo estrutura que recebera os dados do RTC  
....................    date_time_t dt;  
....................    //Variavel que recebe o caractere via serial  
....................    //char c;  
....................   
....................    //Define entradas e saídas em cada Port  
....................    // bit        76543210  
....................    SET_TRIS_B( 0b00000000 );  
181A:  MOVLW  00
181B:  BSF    03.5
181C:  MOVWF  06
....................    SET_TRIS_D( 0b00000000 );  //Port onde está os dados do LCD  
181D:  MOVWF  08
....................   
....................    //habilida a interrupcao via serial  
....................    //enable_interrupts(global);  
....................    //enable_interrupts(int_rda);  
....................    //disable_interrupts(global);  
....................   
....................    //Leva todas as saídas de todos os ports a 0 por causa do LCD  
....................    //portB=0;  
....................    //portD=0;  
....................   
....................    //Inicia com o rele desligado  
....................    output_low(rele);  
181E:  BCF    03.5
181F:  BCF    37.1
1820:  MOVF   37,W
1821:  BSF    03.5
1822:  MOVWF  07
1823:  BCF    03.5
1824:  BCF    07.1
....................   
....................    //Inicializa o LCD  
....................    inicializa_lcd();  
1825:  BCF    0A.4
1826:  BCF    0A.3
1827:  GOTO   0E0
1828:  BSF    0A.4
1829:  BSF    0A.3
....................   
....................    //Cria os caracteres especiaias na CGRAM  
....................    cria_caractere();  
182A:  BCF    0A.4
182B:  BCF    0A.3
182C:  GOTO   123
182D:  BSF    0A.4
182E:  BSF    0A.3
....................   
....................    //Limpa a tela após a criação dos caracteres na CGRAM  
....................    limpa_lcd();  
182F:  BCF    0A.4
1830:  BCF    0A.3
1831:  CALL   0D8
1832:  BSF    0A.4
1833:  BSF    0A.3
....................   
....................    // Inicializa o sensor de temperatura  
....................    RST_Connection();  
1834:  BCF    0A.4
1835:  BCF    0A.3
1836:  GOTO   186
1837:  BSF    0A.4
1838:  BSF    0A.3
....................   
....................    //printf(escreve_lcd," Inicializando");  
....................    //lcd_pos_xy(2,2);  
....................    //printf(escreve_lcd,"Sensor SHT11");  
....................   
....................    //Escreve o valor 0 no Registrador de Status do sensor para zeras as funcoes  
....................    error=WriteStatReg(0x00);  
1839:  CLRF   57
183A:  BCF    0A.4
183B:  BCF    0A.3
183C:  GOTO   1D2
183D:  BSF    0A.4
183E:  BSF    0A.3
183F:  BTFSC  78.0
1840:  GOTO   043
1841:  BCF    34.0
1842:  GOTO   044
1843:  BSF    34.0
....................    // Caso retorne um valor=1 deu erro  
....................    //if (error==1){  
....................       //limpa_lcd();  
....................       //printf(escreve_lcd,"Erro no Sensor");  
....................       //Aguarda 2 segundos  
....................       //delay_ms(2000);  
....................    //}  
....................    //Aguarda 1 segundo  
....................    //delay_ms(1000);  
....................    limpa_lcd();  
1844:  BCF    0A.4
1845:  BCF    0A.3
1846:  CALL   0D8
1847:  BSF    0A.4
1848:  BSF    0A.3
....................   
....................    //Rotina para conseguir um RESET da Max e Min  
....................    //Quando ligar o circuito com a tecla 1 pressionada  
....................    if (tecla1){  
1849:  BSF    37.2
184A:  MOVF   37,W
184B:  BSF    03.5
184C:  MOVWF  07
184D:  BCF    03.5
184E:  BTFSC  07.2
184F:  GOTO   0E7
....................       //Escreve pedindo a confirmação  
....................       printf(escreve_lcd,"RESET Max Min?);  
1850:  CLRF   57
1851:  MOVF   57,W
1852:  BCF    0A.4
1853:  BCF    0A.3
1854:  CALL   031
1855:  BSF    0A.4
1856:  BSF    0A.3
1857:  INCF   57,F
1858:  MOVWF  77
1859:  MOVWF  72
185A:  BCF    0A.4
185B:  BCF    0A.3
185C:  CALL   215
185D:  BSF    0A.4
185E:  BSF    0A.3
185F:  MOVLW  0E
1860:  SUBWF  57,W
1861:  BTFSS  03.2
1862:  GOTO   051
....................       lcd_pos_xy(1,2);  
1863:  MOVLW  01
1864:  MOVWF  71
1865:  MOVLW  02
1866:  MOVWF  72
1867:  BCF    0A.4
1868:  BCF    0A.3
1869:  CALL   21B
186A:  BSF    0A.4
186B:  BSF    0A.3
....................       printf(escreve_lcd,"1=Sim 2=Nao");  
186C:  CLRF   57
186D:  MOVF   57,W
186E:  BCF    0A.4
186F:  BCF    0A.3
1870:  CALL   044
1871:  BSF    0A.4
1872:  BSF    0A.3
1873:  INCF   57,F
1874:  MOVWF  77
1875:  MOVWF  72
1876:  BCF    0A.4
1877:  BCF    0A.3
1878:  CALL   215
1879:  BSF    0A.4
187A:  BSF    0A.3
187B:  MOVLW  0B
187C:  SUBWF  57,W
187D:  BTFSS  03.2
187E:  GOTO   06D
....................       delay_ms(3000);  
187F:  MOVLW  0C
1880:  MOVWF  57
1881:  MOVLW  FA
1882:  MOVWF  70
1883:  BCF    0A.4
1884:  BCF    0A.3
1885:  CALL   075
1886:  BSF    0A.4
1887:  BSF    0A.3
1888:  DECFSZ 57,F
1889:  GOTO   081
....................       while ((!tecla1) || (!tecla2)){  
188A:  BSF    37.2
188B:  MOVF   37,W
188C:  BSF    03.5
188D:  MOVWF  07
188E:  BCF    03.5
188F:  BTFSC  07.2
1890:  GOTO   098
1891:  BSF    37.3
1892:  MOVF   37,W
1893:  BSF    03.5
1894:  MOVWF  07
1895:  BCF    03.5
1896:  BTFSS  07.3
1897:  GOTO   0E7
....................          if (tecla1){  
1898:  BSF    37.2
1899:  MOVF   37,W
189A:  BSF    03.5
189B:  MOVWF  07
189C:  BCF    03.5
189D:  BTFSC  07.2
189E:  GOTO   0E0
....................             //Força o sistema a passar pela condicional fazendo Ftemp ser 1  
....................             write_eeprom(1,0xFF);  
189F:  BSF    03.6
18A0:  CLRF   0E
18A1:  MOVLW  01
18A2:  MOVWF  0D
18A3:  MOVLW  FF
18A4:  MOVWF  0C
18A5:  BSF    03.5
18A6:  BCF    0C.7
18A7:  BSF    0C.2
18A8:  BCF    03.5
18A9:  BCF    03.6
18AA:  MOVF   0B,W
18AB:  MOVWF  77
18AC:  BCF    0B.7
18AD:  BSF    03.5
18AE:  BSF    03.6
18AF:  MOVLW  55
18B0:  MOVWF  0D
18B1:  MOVLW  AA
18B2:  MOVWF  0D
18B3:  BSF    0C.1
18B4:  BTFSC  0C.1
18B5:  GOTO   0B4
18B6:  BCF    0C.2
18B7:  MOVF   77,W
18B8:  BCF    03.5
18B9:  BCF    03.6
18BA:  IORWF  0B,F
....................             Ftemp=1;  
18BB:  BSF    38.1
....................             //Apaga LCD  
....................             limpa_lcd();  
18BC:  BCF    0A.4
18BD:  BCF    0A.3
18BE:  CALL   0D8
18BF:  BSF    0A.4
18C0:  BSF    0A.3
....................             printf(escreve_lcd,"Max/Min Limpos");  
18C1:  CLRF   57
18C2:  MOVF   57,W
18C3:  BCF    0A.4
18C4:  BCF    0A.3
18C5:  CALL   054
18C6:  BSF    0A.4
18C7:  BSF    0A.3
18C8:  INCF   57,F
18C9:  MOVWF  77
18CA:  MOVWF  72
18CB:  BCF    0A.4
18CC:  BCF    0A.3
18CD:  CALL   215
18CE:  BSF    0A.4
18CF:  BSF    0A.3
18D0:  MOVLW  0E
18D1:  SUBWF  57,W
18D2:  BTFSS  03.2
18D3:  GOTO   0C2
....................             //Aguarda 2 segundos  
....................             delay_ms(2000);  
18D4:  MOVLW  08
18D5:  MOVWF  57
18D6:  MOVLW  FA
18D7:  MOVWF  70
18D8:  BCF    0A.4
18D9:  BCF    0A.3
18DA:  CALL   075
18DB:  BSF    0A.4
18DC:  BSF    0A.3
18DD:  DECFSZ 57,F
18DE:  GOTO   0D6
....................          } else {  
18DF:  GOTO   0E6
....................             //Apenas limpa o LCD  
....................             limpa_lcd();  
18E0:  BCF    0A.4
18E1:  BCF    0A.3
18E2:  CALL   0D8
18E3:  BSF    0A.4
18E4:  BSF    0A.3
....................             //Sai do loop  
....................             break;  
18E5:  GOTO   0E7
....................          }  
....................       }  
18E6:  GOTO   08A
....................    }  
....................   
....................    //Escreve na tela   1234567890123456  
....................    printf(escreve_lcd,"   Final 2.0");  
18E7:  MOVLW  03
18E8:  MOVWF  57
18E9:  MOVLW  20
18EA:  MOVWF  72
18EB:  BCF    0A.4
18EC:  BCF    0A.3
18ED:  CALL   215
18EE:  BSF    0A.4
18EF:  BSF    0A.3
18F0:  DECFSZ 57,F
18F1:  GOTO   0E9
18F2:  CLRF   58
18F3:  MOVF   58,W
18F4:  BCF    0A.4
18F5:  BCF    0A.3
18F6:  CALL   067
18F7:  BSF    0A.4
18F8:  BSF    0A.3
18F9:  INCF   58,F
18FA:  MOVWF  77
18FB:  MOVWF  72
18FC:  BCF    0A.4
18FD:  BCF    0A.3
18FE:  CALL   215
18FF:  BSF    0A.4
1900:  BSF    0A.3
1901:  MOVLW  09
1902:  SUBWF  58,W
1903:  BTFSS  03.2
1904:  GOTO   0F3
....................    //Aguarda 2 segundos  
....................    delay_ms(2000);  
1905:  MOVLW  08
1906:  MOVWF  57
1907:  MOVLW  FA
1908:  MOVWF  70
1909:  BCF    0A.4
190A:  BCF    0A.3
190B:  CALL   075
190C:  BSF    0A.4
190D:  BSF    0A.3
190E:  DECFSZ 57,F
190F:  GOTO   107
....................    //Limpa a tela e aguarda a digitação  
....................    limpa_lcd();  
1910:  BCF    0A.4
1911:  BCF    0A.3
1912:  CALL   0D8
1913:  BSF    0A.4
1914:  BSF    0A.3
....................   
....................    //Recupera o endereco da EEPROM na Memoria interna  
....................    mem_pos=read_eeprom_16(17);  
1915:  CLRF   58
1916:  MOVLW  11
1917:  MOVWF  57
1918:  BCF    0A.4
1919:  BCF    0A.3
191A:  GOTO   22D
191B:  BSF    0A.4
191C:  BSF    0A.3
191D:  MOVF   79,W
191E:  MOVWF  21
191F:  MOVF   78,W
1920:  MOVWF  20
....................   
....................    //Compensar o erro de gravação do PIC que seta a EEPROM para 0xFF toda gravação  
....................    if (mem_pos==0xFFFF){  
1921:  INCFSZ 20,W
1922:  GOTO   130
1923:  INCFSZ 21,W
1924:  GOTO   130
....................       mem_pos=0;  
1925:  CLRF   21
1926:  CLRF   20
....................       write_eeprom_16(17,0x00);  
1927:  MOVLW  11
1928:  MOVWF  65
1929:  CLRF   67
192A:  CLRF   66
192B:  BCF    0A.4
192C:  BCF    0A.3
192D:  CALL   25A
192E:  BSF    0A.4
192F:  BSF    0A.3
....................    }  
....................   
....................    //Se já tiver algo gravado na EEPROM não altera nada  
....................    if (!(read_eeprom(1)==0xFF)){  
1930:  BSF    03.6
1931:  CLRF   0E
1932:  MOVLW  01
1933:  MOVWF  0D
1934:  BSF    03.5
1935:  BCF    0C.7
1936:  BSF    0C.0
1937:  BCF    03.5
1938:  MOVF   0C,W
1939:  SUBLW  FF
193A:  BTFSC  03.2
193B:  GOTO   15E
....................       T_Max=read_float_eeprom(1);  
193C:  MOVLW  01
193D:  BCF    03.6
193E:  MOVWF  57
193F:  BCF    0A.4
1940:  BCF    0A.3
1941:  CALL   2A6
1942:  BSF    0A.4
1943:  BSF    0A.3
1944:  MOVF   7A,W
1945:  MOVWF  47
1946:  MOVF   79,W
1947:  MOVWF  46
1948:  MOVF   78,W
1949:  MOVWF  45
194A:  MOVF   77,W
194B:  MOVWF  44
....................       T_Min=read_float_eeprom(9);  
194C:  MOVLW  09
194D:  MOVWF  57
194E:  BCF    0A.4
194F:  BCF    0A.3
1950:  CALL   2A6
1951:  BSF    0A.4
1952:  BSF    0A.3
1953:  MOVF   7A,W
1954:  MOVWF  4B
1955:  MOVF   79,W
1956:  MOVWF  4A
1957:  MOVF   78,W
1958:  MOVWF  49
1959:  MOVF   77,W
195A:  MOVWF  48
....................       Ftemp=0;  
195B:  BCF    38.1
....................    } else { //Se não tiver força a passagem pelo condicional  
195C:  GOTO   160
195D:  BSF    03.6
....................       Ftemp=1;  
195E:  BCF    03.6
195F:  BSF    38.1
....................    }  
....................   
....................    //Zera Temperatura e Umidade  
....................    Temp=0;  
1960:  CLRF   43
1961:  CLRF   42
1962:  CLRF   41
1963:  CLRF   40
....................    RH=0;  
1964:  CLRF   4F
1965:  CLRF   4E
1966:  CLRF   4D
1967:  CLRF   4C
....................   
....................    //Capta os dados para verifiacação da irrigação  
....................   
....................   
....................    //Entra no loop contínuo  
....................    while (true)  
....................    {  
....................   
....................       //Realiza a operação com o led  
....................       output_bit(led,flag);  
1968:  BTFSC  38.0
1969:  GOTO   16C
196A:  BCF    06.7
196B:  GOTO   16D
196C:  BSF    06.7
196D:  BSF    03.5
196E:  BCF    06.7
....................       //Inverte o estado do Led  
....................       flag = !flag;  
196F:  MOVLW  01
1970:  BCF    03.5
1971:  XORWF  38,F
....................   
....................       //Zera a variavel que armazena o erro do sensor  
....................       error=0;  
1972:  BCF    34.0
....................   
....................       //Variavel auxiliar para testar eeprom  
....................       conta++;  
1973:  INCF   39,F
....................   
....................       //Colocado fora do Loop para verificar toda vez  
....................       //Se veio alguma tecla da serial  
....................       if (kbhit())  
1974:  BTFSS  0C.5
1975:  GOTO   186
....................       {  
....................          gets(buffer);  
1976:  MOVLW  22
1977:  MOVWF  04
1978:  DECF   04,F
1979:  INCF   04,F
197A:  BTFSS  0C.5
197B:  GOTO   17A
197C:  MOVF   1A,W
197D:  MOVWF  00
197E:  MOVLW  0D
197F:  SUBWF  00,W
1980:  BTFSS  03.2
1981:  GOTO   179
1982:  CLRF   00
....................          trata_serial();  
1983:  BCF    0A.4
1984:  GOTO   000
1985:  BSF    0A.4
....................       }  
....................       //Faz a leitura do RTC para pegar a hora,minuto,segundo  
....................       PCF8583_read_datetime(&dt);  
1986:  MOVLW  50
1987:  MOVWF  6F
1988:  BCF    0A.4
1989:  CALL   246
198A:  BSF    0A.4
....................   
....................       //Escreve a hora do RTC na tela de LCD  
....................       lcd_pos_xy(1,1);  
198B:  MOVLW  01
198C:  MOVWF  71
198D:  MOVWF  72
198E:  BCF    0A.4
198F:  BCF    0A.3
1990:  CALL   21B
1991:  BSF    0A.4
1992:  BSF    0A.3
....................       printf(escreve_lcd,"%02u/%02u",dt.day,dt.month);  
1993:  MOVF   53,W
1994:  MOVWF  70
1995:  MOVLW  01
1996:  MOVWF  71
1997:  BCF    0A.4
1998:  BCF    0A.3
1999:  CALL   7B0
199A:  BSF    0A.4
199B:  BSF    0A.3
199C:  MOVLW  2F
199D:  MOVWF  72
199E:  BCF    0A.4
199F:  BCF    0A.3
19A0:  CALL   215
19A1:  BSF    0A.4
19A2:  BSF    0A.3
19A3:  MOVF   54,W
19A4:  MOVWF  70
19A5:  MOVLW  01
19A6:  MOVWF  71
19A7:  BCF    0A.4
19A8:  BCF    0A.3
19A9:  CALL   7B0
19AA:  BSF    0A.4
19AB:  BSF    0A.3
....................       lcd_pos_xy(1,2);  
19AC:  MOVLW  01
19AD:  MOVWF  71
19AE:  MOVLW  02
19AF:  MOVWF  72
19B0:  BCF    0A.4
19B1:  BCF    0A.3
19B2:  CALL   21B
19B3:  BSF    0A.4
19B4:  BSF    0A.3
....................       printf(escreve_lcd,"%02u:%02u",dt.hours,dt.minutes);  
19B5:  MOVF   52,W
19B6:  MOVWF  70
19B7:  MOVLW  01
19B8:  MOVWF  71
19B9:  BCF    0A.4
19BA:  BCF    0A.3
19BB:  CALL   7B0
19BC:  BSF    0A.4
19BD:  BSF    0A.3
19BE:  MOVLW  3A
19BF:  MOVWF  72
19C0:  BCF    0A.4
19C1:  BCF    0A.3
19C2:  CALL   215
19C3:  BSF    0A.4
19C4:  BSF    0A.3
19C5:  MOVF   51,W
19C6:  MOVWF  70
19C7:  MOVLW  01
19C8:  MOVWF  71
19C9:  BCF    0A.4
19CA:  BCF    0A.3
19CB:  CALL   7B0
19CC:  BSF    0A.4
19CD:  BSF    0A.3
....................       // 99/99  
....................       // 00:00  
....................   
....................       //Mostra a temperatura e umidade no LCD  
....................       lcd_pos_xy(12,1);  
19CE:  MOVLW  0C
19CF:  MOVWF  71
19D0:  MOVLW  01
19D1:  MOVWF  72
19D2:  BCF    0A.4
19D3:  BCF    0A.3
19D4:  CALL   21B
19D5:  BSF    0A.4
19D6:  BSF    0A.3
....................       printf(escreve_lcd,"%2.1fC",Temp);  
19D7:  MOVF   43,W
19D8:  MOVWF  61
19D9:  MOVF   42,W
19DA:  MOVWF  60
19DB:  MOVF   41,W
19DC:  MOVWF  5F
19DD:  MOVF   40,W
19DE:  MOVWF  5E
19DF:  CLRF   65
19E0:  CLRF   64
19E1:  MOVLW  01
19E2:  MOVWF  63
19E3:  MOVWF  62
19E4:  BCF    0A.4
19E5:  CALL   359
19E6:  BSF    0A.4
19E7:  MOVLW  43
19E8:  MOVWF  72
19E9:  BCF    0A.4
19EA:  BCF    0A.3
19EB:  CALL   215
19EC:  BSF    0A.4
19ED:  BSF    0A.3
....................       lcd_pos_xy(12,2);  
19EE:  MOVLW  0C
19EF:  MOVWF  71
19F0:  MOVLW  02
19F1:  MOVWF  72
19F2:  BCF    0A.4
19F3:  BCF    0A.3
19F4:  CALL   21B
19F5:  BSF    0A.4
19F6:  BSF    0A.3
....................       printf(escreve_lcd,"%3.1f%%",RH);  
19F7:  MOVF   4F,W
19F8:  MOVWF  61
19F9:  MOVF   4E,W
19FA:  MOVWF  60
19FB:  MOVF   4D,W
19FC:  MOVWF  5F
19FD:  MOVF   4C,W
19FE:  MOVWF  5E
19FF:  CLRF   65
1A00:  CLRF   64
1A01:  MOVLW  01
1A02:  MOVWF  63
1A03:  MOVWF  62
1A04:  BCF    0A.4
1A05:  CALL   359
1A06:  BSF    0A.4
1A07:  MOVLW  25
1A08:  MOVWF  72
1A09:  BCF    0A.4
1A0A:  BCF    0A.3
1A0B:  CALL   215
1A0C:  BSF    0A.4
1A0D:  BSF    0A.3
....................   
....................       //Define a conversão para ocorrer apenas a cada 5 segundos  
....................       if (!(conta % 5)) {  
1A0E:  MOVF   39,W
1A0F:  MOVWF  72
1A10:  MOVLW  05
1A11:  MOVWF  73
1A12:  BCF    0A.4
1A13:  BCF    0A.3
1A14:  CALL   372
1A15:  BSF    0A.4
1A16:  BSF    0A.3
1A17:  MOVF   77,W
1A18:  BTFSS  03.2
1A19:  GOTO   505
....................   
.................... /******************************************************************************  
.................... *  Leitura do Sensor SHT11                                                   *  
.................... ******************************************************************************/  
....................   
....................          // Mede a temperatura no sensor combinado SHT11  
....................          Temp = ReadTemperature();  
1A1A:  BCF    0A.4
1A1B:  GOTO   751
1A1C:  BSF    0A.4
1A1D:  MOVF   7A,W
1A1E:  MOVWF  43
1A1F:  MOVF   79,W
1A20:  MOVWF  42
1A21:  MOVF   78,W
1A22:  MOVWF  41
1A23:  MOVF   77,W
1A24:  MOVWF  40
....................          // Mede a umidade relativa do ar no sensor combinado SHT11  
....................          RH =   ReadHumidity();  
1A25:  BCF    0A.3
1A26:  GOTO   000
1A27:  BSF    0A.3
1A28:  MOVF   79,W
1A29:  MOVWF  6E
1A2A:  MOVF   78,W
1A2B:  MOVWF  6D
1A2C:  BCF    0A.4
1A2D:  BCF    0A.3
1A2E:  CALL   7E2
1A2F:  BSF    0A.4
1A30:  BSF    0A.3
1A31:  MOVF   7A,W
1A32:  MOVWF  4F
1A33:  MOVF   79,W
1A34:  MOVWF  4E
1A35:  MOVF   78,W
1A36:  MOVWF  4D
1A37:  MOVF   77,W
1A38:  MOVWF  4C
....................   
.................... /******************************************************************************  
.................... *  Faz todo o registro de temperatura maxima e minima registrada              *  
.................... ******************************************************************************/  
....................   
....................          //Primeira vez que passa aqui, zera as temperaturas para evitar erro  
....................          if (Ftemp)  
1A39:  BTFSS  38.1
1A3A:  GOTO   356
....................          {  
....................             T_Max=Temp;  
1A3B:  MOVF   43,W
1A3C:  MOVWF  47
1A3D:  MOVF   42,W
1A3E:  MOVWF  46
1A3F:  MOVF   41,W
1A40:  MOVWF  45
1A41:  MOVF   40,W
1A42:  MOVWF  44
....................             T_Min=Temp;  
1A43:  MOVF   43,W
1A44:  MOVWF  4B
1A45:  MOVF   42,W
1A46:  MOVWF  4A
1A47:  MOVF   41,W
1A48:  MOVWF  49
1A49:  MOVF   40,W
1A4A:  MOVWF  48
....................             //Escreve na EEPROM interna a Maxima e a hora que ocorreu  
....................             write_float_eeprom(1,T_Max);  
1A4B:  MOVLW  01
1A4C:  MOVWF  57
1A4D:  MOVF   47,W
1A4E:  MOVWF  5B
1A4F:  MOVF   46,W
1A50:  MOVWF  5A
1A51:  MOVF   45,W
1A52:  MOVWF  59
1A53:  MOVF   44,W
1A54:  MOVWF  58
1A55:  BCF    0A.3
1A56:  CALL   0F1
1A57:  BSF    0A.3
....................             write_eeprom(5,dt.hours);  
1A58:  BSF    03.6
1A59:  CLRF   0E
1A5A:  MOVLW  05
1A5B:  MOVWF  0D
1A5C:  BCF    03.6
1A5D:  MOVF   52,W
1A5E:  BSF    03.6
1A5F:  MOVWF  0C
1A60:  BSF    03.5
1A61:  BCF    0C.7
1A62:  BSF    0C.2
1A63:  BCF    03.5
1A64:  BCF    03.6
1A65:  MOVF   0B,W
1A66:  MOVWF  77
1A67:  BCF    0B.7
1A68:  BSF    03.5
1A69:  BSF    03.6
1A6A:  MOVLW  55
1A6B:  MOVWF  0D
1A6C:  MOVLW  AA
1A6D:  MOVWF  0D
1A6E:  BSF    0C.1
1A6F:  BTFSC  0C.1
1A70:  GOTO   26F
1A71:  BCF    0C.2
1A72:  MOVF   77,W
1A73:  BCF    03.5
1A74:  BCF    03.6
1A75:  IORWF  0B,F
....................             write_eeprom(6,dt.minutes);  
1A76:  BSF    03.6
1A77:  CLRF   0E
1A78:  MOVLW  06
1A79:  MOVWF  0D
1A7A:  BCF    03.6
1A7B:  MOVF   51,W
1A7C:  BSF    03.6
1A7D:  MOVWF  0C
1A7E:  BSF    03.5
1A7F:  BCF    0C.7
1A80:  BSF    0C.2
1A81:  BCF    03.5
1A82:  BCF    03.6
1A83:  MOVF   0B,W
1A84:  MOVWF  77
1A85:  BCF    0B.7
1A86:  BSF    03.5
1A87:  BSF    03.6
1A88:  MOVLW  55
1A89:  MOVWF  0D
1A8A:  MOVLW  AA
1A8B:  MOVWF  0D
1A8C:  BSF    0C.1
1A8D:  BTFSC  0C.1
1A8E:  GOTO   28D
1A8F:  BCF    0C.2
1A90:  MOVF   77,W
1A91:  BCF    03.5
1A92:  BCF    03.6
1A93:  IORWF  0B,F
....................             write_eeprom(7,dt.day);  
1A94:  BSF    03.6
1A95:  CLRF   0E
1A96:  MOVLW  07
1A97:  MOVWF  0D
1A98:  BCF    03.6
1A99:  MOVF   53,W
1A9A:  BSF    03.6
1A9B:  MOVWF  0C
1A9C:  BSF    03.5
1A9D:  BCF    0C.7
1A9E:  BSF    0C.2
1A9F:  BCF    03.5
1AA0:  BCF    03.6
1AA1:  MOVF   0B,W
1AA2:  MOVWF  77
1AA3:  BCF    0B.7
1AA4:  BSF    03.5
1AA5:  BSF    03.6
1AA6:  MOVLW  55
1AA7:  MOVWF  0D
1AA8:  MOVLW  AA
1AA9:  MOVWF  0D
1AAA:  BSF    0C.1
1AAB:  BTFSC  0C.1
1AAC:  GOTO   2AB
1AAD:  BCF    0C.2
1AAE:  MOVF   77,W
1AAF:  BCF    03.5
1AB0:  BCF    03.6
1AB1:  IORWF  0B,F
....................             write_eeprom(8,dt.month);  
1AB2:  BSF    03.6
1AB3:  CLRF   0E
1AB4:  MOVLW  08
1AB5:  MOVWF  0D
1AB6:  BCF    03.6
1AB7:  MOVF   54,W
1AB8:  BSF    03.6
1AB9:  MOVWF  0C
1ABA:  BSF    03.5
1ABB:  BCF    0C.7
1ABC:  BSF    0C.2
1ABD:  BCF    03.5
1ABE:  BCF    03.6
1ABF:  MOVF   0B,W
1AC0:  MOVWF  77
1AC1:  BCF    0B.7
1AC2:  BSF    03.5
1AC3:  BSF    03.6
1AC4:  MOVLW  55
1AC5:  MOVWF  0D
1AC6:  MOVLW  AA
1AC7:  MOVWF  0D
1AC8:  BSF    0C.1
1AC9:  BTFSC  0C.1
1ACA:  GOTO   2C9
1ACB:  BCF    0C.2
1ACC:  MOVF   77,W
1ACD:  BCF    03.5
1ACE:  BCF    03.6
1ACF:  IORWF  0B,F
....................             //Escreve na EEPROM interna a Minima e a hora que ocorreu  
....................             write_float_eeprom(9,T_Min);  
1AD0:  MOVLW  09
1AD1:  MOVWF  57
1AD2:  MOVF   4B,W
1AD3:  MOVWF  5B
1AD4:  MOVF   4A,W
1AD5:  MOVWF  5A
1AD6:  MOVF   49,W
1AD7:  MOVWF  59
1AD8:  MOVF   48,W
1AD9:  MOVWF  58
1ADA:  BCF    0A.3
1ADB:  CALL   0F1
1ADC:  BSF    0A.3
....................             write_eeprom(13,dt.hours);  
1ADD:  BSF    03.6
1ADE:  CLRF   0E
1ADF:  MOVLW  0D
1AE0:  MOVWF  0D
1AE1:  BCF    03.6
1AE2:  MOVF   52,W
1AE3:  BSF    03.6
1AE4:  MOVWF  0C
1AE5:  BSF    03.5
1AE6:  BCF    0C.7
1AE7:  BSF    0C.2
1AE8:  BCF    03.5
1AE9:  BCF    03.6
1AEA:  MOVF   0B,W
1AEB:  MOVWF  77
1AEC:  BCF    0B.7
1AED:  BSF    03.5
1AEE:  BSF    03.6
1AEF:  MOVLW  55
1AF0:  MOVWF  0D
1AF1:  MOVLW  AA
1AF2:  MOVWF  0D
1AF3:  BSF    0C.1
1AF4:  BTFSC  0C.1
1AF5:  GOTO   2F4
1AF6:  BCF    0C.2
1AF7:  MOVF   77,W
1AF8:  BCF    03.5
1AF9:  BCF    03.6
1AFA:  IORWF  0B,F
....................             write_eeprom(14,dt.minutes);  
1AFB:  BSF    03.6
1AFC:  CLRF   0E
1AFD:  MOVLW  0E
1AFE:  MOVWF  0D
1AFF:  BCF    03.6
1B00:  MOVF   51,W
1B01:  BSF    03.6
1B02:  MOVWF  0C
1B03:  BSF    03.5
1B04:  BCF    0C.7
1B05:  BSF    0C.2
1B06:  BCF    03.5
1B07:  BCF    03.6
1B08:  MOVF   0B,W
1B09:  MOVWF  77
1B0A:  BCF    0B.7
1B0B:  BSF    03.5
1B0C:  BSF    03.6
1B0D:  MOVLW  55
1B0E:  MOVWF  0D
1B0F:  MOVLW  AA
1B10:  MOVWF  0D
1B11:  BSF    0C.1
1B12:  BTFSC  0C.1
1B13:  GOTO   312
1B14:  BCF    0C.2
1B15:  MOVF   77,W
1B16:  BCF    03.5
1B17:  BCF    03.6
1B18:  IORWF  0B,F
....................             write_eeprom(15,dt.day);  
1B19:  BSF    03.6
1B1A:  CLRF   0E
1B1B:  MOVLW  0F
1B1C:  MOVWF  0D
1B1D:  BCF    03.6
1B1E:  MOVF   53,W
1B1F:  BSF    03.6
1B20:  MOVWF  0C
1B21:  BSF    03.5
1B22:  BCF    0C.7
1B23:  BSF    0C.2
1B24:  BCF    03.5
1B25:  BCF    03.6
1B26:  MOVF   0B,W
1B27:  MOVWF  77
1B28:  BCF    0B.7
1B29:  BSF    03.5
1B2A:  BSF    03.6
1B2B:  MOVLW  55
1B2C:  MOVWF  0D
1B2D:  MOVLW  AA
1B2E:  MOVWF  0D
1B2F:  BSF    0C.1
1B30:  BTFSC  0C.1
1B31:  GOTO   330
1B32:  BCF    0C.2
1B33:  MOVF   77,W
1B34:  BCF    03.5
1B35:  BCF    03.6
1B36:  IORWF  0B,F
....................             write_eeprom(16,dt.month);  
1B37:  BSF    03.6
1B38:  CLRF   0E
1B39:  MOVLW  10
1B3A:  MOVWF  0D
1B3B:  BCF    03.6
1B3C:  MOVF   54,W
1B3D:  BSF    03.6
1B3E:  MOVWF  0C
1B3F:  BSF    03.5
1B40:  BCF    0C.7
1B41:  BSF    0C.2
1B42:  BCF    03.5
1B43:  BCF    03.6
1B44:  MOVF   0B,W
1B45:  MOVWF  77
1B46:  BCF    0B.7
1B47:  BSF    03.5
1B48:  BSF    03.6
1B49:  MOVLW  55
1B4A:  MOVWF  0D
1B4B:  MOVLW  AA
1B4C:  MOVWF  0D
1B4D:  BSF    0C.1
1B4E:  BTFSC  0C.1
1B4F:  GOTO   34E
1B50:  BCF    0C.2
1B51:  MOVF   77,W
1B52:  BCF    03.5
1B53:  BCF    03.6
1B54:  IORWF  0B,F
....................             Ftemp=0;  
1B55:  BCF    38.1
....................          }  
....................   
....................          //Verifica se a temperatura é maxima ou minima e grava na EEPROM Interna  
....................          if (Temp > T_Max) {  
1B56:  MOVF   47,W
1B57:  MOVWF  5A
1B58:  MOVF   46,W
1B59:  MOVWF  59
1B5A:  MOVF   45,W
1B5B:  MOVWF  58
1B5C:  MOVF   44,W
1B5D:  MOVWF  57
1B5E:  MOVF   43,W
1B5F:  MOVWF  5E
1B60:  MOVF   42,W
1B61:  MOVWF  5D
1B62:  MOVF   41,W
1B63:  MOVWF  5C
1B64:  MOVF   40,W
1B65:  MOVWF  5B
1B66:  BCF    0A.3
1B67:  CALL   121
1B68:  BSF    0A.3
1B69:  BTFSS  03.0
1B6A:  GOTO   3F0
....................             write_float_eeprom(1,Temp);  
1B6B:  MOVLW  01
1B6C:  MOVWF  57
1B6D:  MOVF   43,W
1B6E:  MOVWF  5B
1B6F:  MOVF   42,W
1B70:  MOVWF  5A
1B71:  MOVF   41,W
1B72:  MOVWF  59
1B73:  MOVF   40,W
1B74:  MOVWF  58
1B75:  BCF    0A.3
1B76:  CALL   0F1
1B77:  BSF    0A.3
....................             write_eeprom(5,dt.hours);  
1B78:  BSF    03.6
1B79:  CLRF   0E
1B7A:  MOVLW  05
1B7B:  MOVWF  0D
1B7C:  BCF    03.6
1B7D:  MOVF   52,W
1B7E:  BSF    03.6
1B7F:  MOVWF  0C
1B80:  BSF    03.5
1B81:  BCF    0C.7
1B82:  BSF    0C.2
1B83:  BCF    03.5
1B84:  BCF    03.6
1B85:  MOVF   0B,W
1B86:  MOVWF  77
1B87:  BCF    0B.7
1B88:  BSF    03.5
1B89:  BSF    03.6
1B8A:  MOVLW  55
1B8B:  MOVWF  0D
1B8C:  MOVLW  AA
1B8D:  MOVWF  0D
1B8E:  BSF    0C.1
1B8F:  BTFSC  0C.1
1B90:  GOTO   38F
1B91:  BCF    0C.2
1B92:  MOVF   77,W
1B93:  BCF    03.5
1B94:  BCF    03.6
1B95:  IORWF  0B,F
....................             write_eeprom(6,dt.minutes);  
1B96:  BSF    03.6
1B97:  CLRF   0E
1B98:  MOVLW  06
1B99:  MOVWF  0D
1B9A:  BCF    03.6
1B9B:  MOVF   51,W
1B9C:  BSF    03.6
1B9D:  MOVWF  0C
1B9E:  BSF    03.5
1B9F:  BCF    0C.7
1BA0:  BSF    0C.2
1BA1:  BCF    03.5
1BA2:  BCF    03.6
1BA3:  MOVF   0B,W
1BA4:  MOVWF  77
1BA5:  BCF    0B.7
1BA6:  BSF    03.5
1BA7:  BSF    03.6
1BA8:  MOVLW  55
1BA9:  MOVWF  0D
1BAA:  MOVLW  AA
1BAB:  MOVWF  0D
1BAC:  BSF    0C.1
1BAD:  BTFSC  0C.1
1BAE:  GOTO   3AD
1BAF:  BCF    0C.2
1BB0:  MOVF   77,W
1BB1:  BCF    03.5
1BB2:  BCF    03.6
1BB3:  IORWF  0B,F
....................             write_eeprom(7,dt.day);  
1BB4:  BSF    03.6
1BB5:  CLRF   0E
1BB6:  MOVLW  07
1BB7:  MOVWF  0D
1BB8:  BCF    03.6
1BB9:  MOVF   53,W
1BBA:  BSF    03.6
1BBB:  MOVWF  0C
1BBC:  BSF    03.5
1BBD:  BCF    0C.7
1BBE:  BSF    0C.2
1BBF:  BCF    03.5
1BC0:  BCF    03.6
1BC1:  MOVF   0B,W
1BC2:  MOVWF  77
1BC3:  BCF    0B.7
1BC4:  BSF    03.5
1BC5:  BSF    03.6
1BC6:  MOVLW  55
1BC7:  MOVWF  0D
1BC8:  MOVLW  AA
1BC9:  MOVWF  0D
1BCA:  BSF    0C.1
1BCB:  BTFSC  0C.1
1BCC:  GOTO   3CB
1BCD:  BCF    0C.2
1BCE:  MOVF   77,W
1BCF:  BCF    03.5
1BD0:  BCF    03.6
1BD1:  IORWF  0B,F
....................             write_eeprom(8,dt.month);  
1BD2:  BSF    03.6
1BD3:  CLRF   0E
1BD4:  MOVLW  08
1BD5:  MOVWF  0D
1BD6:  BCF    03.6
1BD7:  MOVF   54,W
1BD8:  BSF    03.6
1BD9:  MOVWF  0C
1BDA:  BSF    03.5
1BDB:  BCF    0C.7
1BDC:  BSF    0C.2
1BDD:  BCF    03.5
1BDE:  BCF    03.6
1BDF:  MOVF   0B,W
1BE0:  MOVWF  77
1BE1:  BCF    0B.7
1BE2:  BSF    03.5
1BE3:  BSF    03.6
1BE4:  MOVLW  55
1BE5:  MOVWF  0D
1BE6:  MOVLW  AA
1BE7:  MOVWF  0D
1BE8:  BSF    0C.1
1BE9:  BTFSC  0C.1
1BEA:  GOTO   3E9
1BEB:  BCF    0C.2
1BEC:  MOVF   77,W
1BED:  BCF    03.5
1BEE:  BCF    03.6
1BEF:  IORWF  0B,F
....................          }  
....................          if (Temp < T_Min) {  
1BF0:  MOVF   43,W
1BF1:  MOVWF  5A
1BF2:  MOVF   42,W
1BF3:  MOVWF  59
1BF4:  MOVF   41,W
1BF5:  MOVWF  58
1BF6:  MOVF   40,W
1BF7:  MOVWF  57
1BF8:  MOVF   4B,W
1BF9:  MOVWF  5E
1BFA:  MOVF   4A,W
1BFB:  MOVWF  5D
1BFC:  MOVF   49,W
1BFD:  MOVWF  5C
1BFE:  MOVF   48,W
1BFF:  MOVWF  5B
1C00:  BCF    0A.3
1C01:  CALL   121
1C02:  BSF    0A.3
1C03:  BTFSS  03.0
1C04:  GOTO   48A
....................             write_float_eeprom(9,Temp);  
1C05:  MOVLW  09
1C06:  MOVWF  57
1C07:  MOVF   43,W
1C08:  MOVWF  5B
1C09:  MOVF   42,W
1C0A:  MOVWF  5A
1C0B:  MOVF   41,W
1C0C:  MOVWF  59
1C0D:  MOVF   40,W
1C0E:  MOVWF  58
1C0F:  BCF    0A.3
1C10:  CALL   0F1
1C11:  BSF    0A.3
....................             write_eeprom(13,dt.hours);  
1C12:  BSF    03.6
1C13:  CLRF   0E
1C14:  MOVLW  0D
1C15:  MOVWF  0D
1C16:  BCF    03.6
1C17:  MOVF   52,W
1C18:  BSF    03.6
1C19:  MOVWF  0C
1C1A:  BSF    03.5
1C1B:  BCF    0C.7
1C1C:  BSF    0C.2
1C1D:  BCF    03.5
1C1E:  BCF    03.6
1C1F:  MOVF   0B,W
1C20:  MOVWF  77
1C21:  BCF    0B.7
1C22:  BSF    03.5
1C23:  BSF    03.6
1C24:  MOVLW  55
1C25:  MOVWF  0D
1C26:  MOVLW  AA
1C27:  MOVWF  0D
1C28:  BSF    0C.1
1C29:  BTFSC  0C.1
1C2A:  GOTO   429
1C2B:  BCF    0C.2
1C2C:  MOVF   77,W
1C2D:  BCF    03.5
1C2E:  BCF    03.6
1C2F:  IORWF  0B,F
....................             write_eeprom(14,dt.minutes);  
1C30:  BSF    03.6
1C31:  CLRF   0E
1C32:  MOVLW  0E
1C33:  MOVWF  0D
1C34:  BCF    03.6
1C35:  MOVF   51,W
1C36:  BSF    03.6
1C37:  MOVWF  0C
1C38:  BSF    03.5
1C39:  BCF    0C.7
1C3A:  BSF    0C.2
1C3B:  BCF    03.5
1C3C:  BCF    03.6
1C3D:  MOVF   0B,W
1C3E:  MOVWF  77
1C3F:  BCF    0B.7
1C40:  BSF    03.5
1C41:  BSF    03.6
1C42:  MOVLW  55
1C43:  MOVWF  0D
1C44:  MOVLW  AA
1C45:  MOVWF  0D
1C46:  BSF    0C.1
1C47:  BTFSC  0C.1
1C48:  GOTO   447
1C49:  BCF    0C.2
1C4A:  MOVF   77,W
1C4B:  BCF    03.5
1C4C:  BCF    03.6
1C4D:  IORWF  0B,F
....................             write_eeprom(15,dt.day);  
1C4E:  BSF    03.6
1C4F:  CLRF   0E
1C50:  MOVLW  0F
1C51:  MOVWF  0D
1C52:  BCF    03.6
1C53:  MOVF   53,W
1C54:  BSF    03.6
1C55:  MOVWF  0C
1C56:  BSF    03.5
1C57:  BCF    0C.7
1C58:  BSF    0C.2
1C59:  BCF    03.5
1C5A:  BCF    03.6
1C5B:  MOVF   0B,W
1C5C:  MOVWF  77
1C5D:  BCF    0B.7
1C5E:  BSF    03.5
1C5F:  BSF    03.6
1C60:  MOVLW  55
1C61:  MOVWF  0D
1C62:  MOVLW  AA
1C63:  MOVWF  0D
1C64:  BSF    0C.1
1C65:  BTFSC  0C.1
1C66:  GOTO   465
1C67:  BCF    0C.2
1C68:  MOVF   77,W
1C69:  BCF    03.5
1C6A:  BCF    03.6
1C6B:  IORWF  0B,F
....................             write_eeprom(16,dt.month);  
1C6C:  BSF    03.6
1C6D:  CLRF   0E
1C6E:  MOVLW  10
1C6F:  MOVWF  0D
1C70:  BCF    03.6
1C71:  MOVF   54,W
1C72:  BSF    03.6
1C73:  MOVWF  0C
1C74:  BSF    03.5
1C75:  BCF    0C.7
1C76:  BSF    0C.2
1C77:  BCF    03.5
1C78:  BCF    03.6
1C79:  MOVF   0B,W
1C7A:  MOVWF  77
1C7B:  BCF    0B.7
1C7C:  BSF    03.5
1C7D:  BSF    03.6
1C7E:  MOVLW  55
1C7F:  MOVWF  0D
1C80:  MOVLW  AA
1C81:  MOVWF  0D
1C82:  BSF    0C.1
1C83:  BTFSC  0C.1
1C84:  GOTO   483
1C85:  BCF    0C.2
1C86:  MOVF   77,W
1C87:  BCF    03.5
1C88:  BCF    03.6
1C89:  IORWF  0B,F
....................          }  
....................   
....................   
.................... /**************************************************************  
.................... *   Registro de temperatura                                   *  
.................... ***************************************************************/  
....................   
....................          //Primeiro verifica se a memória não está cheia  
....................          if (mem_pos<8191){  
1C8A:  MOVF   21,W
1C8B:  SUBLW  1F
1C8C:  BTFSS  03.0
1C8D:  GOTO   505
1C8E:  BTFSS  03.2
1C8F:  GOTO   494
1C90:  MOVF   20,W
1C91:  SUBLW  FE
1C92:  BTFSS  03.0
1C93:  GOTO   505
....................   
....................             //A cada 4 horas  
....................             if (!(dt.hours % 4)) //Horas  
1C94:  MOVF   52,W
1C95:  ANDLW  03
1C96:  XORLW  00
1C97:  BTFSS  03.2
1C98:  GOTO   503
....................             {  
....................                if (Fregistro){  
1C99:  BTFSS  38.2
1C9A:  GOTO   502
....................                   //Registra o Dia  
....................                   escreve_eeprom(0,mem_pos,dt.day);  
1C9B:  CLRF   65
1C9C:  MOVF   21,W
1C9D:  MOVWF  67
1C9E:  MOVF   20,W
1C9F:  MOVWF  66
1CA0:  MOVF   53,W
1CA1:  MOVWF  68
1CA2:  BCF    0A.4
1CA3:  BCF    0A.3
1CA4:  CALL   44F
1CA5:  BSF    0A.4
1CA6:  BSF    0A.3
....................                   mem_pos++;  
1CA7:  INCF   20,F
1CA8:  BTFSC  03.2
1CA9:  INCF   21,F
....................                   //Registra o Mes  
....................                   escreve_eeprom(0,mem_pos,dt.month);  
1CAA:  CLRF   65
1CAB:  MOVF   21,W
1CAC:  MOVWF  67
1CAD:  MOVF   20,W
1CAE:  MOVWF  66
1CAF:  MOVF   54,W
1CB0:  MOVWF  68
1CB1:  BCF    0A.4
1CB2:  BCF    0A.3
1CB3:  CALL   44F
1CB4:  BSF    0A.4
1CB5:  BSF    0A.3
....................                   mem_pos++;  
1CB6:  INCF   20,F
1CB7:  BTFSC  03.2
1CB8:  INCF   21,F
....................                   //Registra a hora  
....................                   escreve_eeprom(0,mem_pos,dt.hours);  
1CB9:  CLRF   65
1CBA:  MOVF   21,W
1CBB:  MOVWF  67
1CBC:  MOVF   20,W
1CBD:  MOVWF  66
1CBE:  MOVF   52,W
1CBF:  MOVWF  68
1CC0:  BCF    0A.4
1CC1:  BCF    0A.3
1CC2:  CALL   44F
1CC3:  BSF    0A.4
1CC4:  BSF    0A.3
....................                   mem_pos++;  
1CC5:  INCF   20,F
1CC6:  BTFSC  03.2
1CC7:  INCF   21,F
....................                   //Registra a humidade  
....................                   escreve_eeprom(0,mem_pos,(int) RH);  
1CC8:  MOVF   4F,W
1CC9:  MOVWF  60
1CCA:  MOVF   4E,W
1CCB:  MOVWF  5F
1CCC:  MOVF   4D,W
1CCD:  MOVWF  5E
1CCE:  MOVF   4C,W
1CCF:  MOVWF  5D
1CD0:  BCF    0A.4
1CD1:  CALL   7BC
1CD2:  BSF    0A.4
1CD3:  MOVF   78,W
1CD4:  MOVWF  57
1CD5:  CLRF   65
1CD6:  MOVF   21,W
1CD7:  MOVWF  67
1CD8:  MOVF   20,W
1CD9:  MOVWF  66
1CDA:  MOVF   57,W
1CDB:  MOVWF  68
1CDC:  BCF    0A.4
1CDD:  BCF    0A.3
1CDE:  CALL   44F
1CDF:  BSF    0A.4
1CE0:  BSF    0A.3
....................                   mem_pos++;  
1CE1:  INCF   20,F
1CE2:  BTFSC  03.2
1CE3:  INCF   21,F
....................                   //Registra a temperatura  
....................                   //Funcao especial para escrever 16 bits na eeprom externa  
....................                   escreve_eeprom_16(0,mem_pos,Temp_16);  
1CE4:  CLRF   57
1CE5:  MOVF   21,W
1CE6:  MOVWF  59
1CE7:  MOVF   20,W
1CE8:  MOVWF  58
1CE9:  MOVF   3F,W
1CEA:  MOVWF  5B
1CEB:  MOVF   3E,W
1CEC:  MOVWF  5A
1CED:  BCF    0A.3
1CEE:  GOTO   160
1CEF:  BSF    0A.3
....................                   //uma variável long ocupa 16 bits ou seja 2 bytes  
....................                   mem_pos++;  
1CF0:  INCF   20,F
1CF1:  BTFSC  03.2
1CF2:  INCF   21,F
....................                   mem_pos++;  
1CF3:  INCF   20,F
1CF4:  BTFSC  03.2
1CF5:  INCF   21,F
....................                   //Guarda a posicao atual da EEPROM externa, na memoria interna  
....................                   write_eeprom_16(17,mem_pos);  
1CF6:  MOVLW  11
1CF7:  MOVWF  65
1CF8:  MOVF   21,W
1CF9:  MOVWF  67
1CFA:  MOVF   20,W
1CFB:  MOVWF  66
1CFC:  BCF    0A.4
1CFD:  BCF    0A.3
1CFE:  CALL   25A
1CFF:  BSF    0A.4
1D00:  BSF    0A.3
....................                   //Sinaliza que já foi armazenada a temperatura  
....................                   Fregistro=0;  
1D01:  BCF    38.2
....................                   //Posiciona o cursor e escreve o registro de controle  
....................                   //lcd_pos_xy(7,2);  
....................                   //printf(escreve_lcd,"%04lu",(int16)(mem_pos/6));  
....................                   //Divide por 6 porque cada registro ocupa 6 bytes na EEPROM  
....................                }  
....................             } else {  
1D02:  GOTO   504
....................                Fregistro=1;  
1D03:  BSF    38.2
....................             }  
....................          } else {  
1D04:  GOTO   505
....................             //Se a memoria estiver cheia avisa no LCD  
....................             //Posiciona o cursor e escreve o registro de controle  
....................             //lcd_pos_xy(7,2);  
....................             //printf(escreve_lcd,"FULL");  
....................          }  
....................       } // Fecha o bloco dos 5 segundos  
....................   
.................... /******************************************************************************  
.................... *   Controle de irrigação                                *  
.................... ******************************************************************************/  
....................   
....................       //Nesta Versão o controle é feito todo por Array  
....................   
....................       for (a=0 ; a <= 10 ; a++){  
1D05:  CLRF   3A
1D06:  MOVF   3A,W
1D07:  SUBLW  0A
1D08:  BTFSS  03.0
1D09:  GOTO   562
....................          if (dt.hours == read_eeprom(20+(a*3))){  
1D0A:  MOVF   3A,W
1D0B:  MOVWF  65
1D0C:  MOVLW  03
1D0D:  MOVWF  66
1D0E:  BCF    0A.4
1D0F:  BCF    0A.3
1D10:  CALL   6AA
1D11:  BSF    0A.4
1D12:  BSF    0A.3
1D13:  MOVF   78,W
1D14:  ADDLW  14
1D15:  MOVWF  57
1D16:  BSF    03.6
1D17:  CLRF   0E
1D18:  BCF    03.6
1D19:  MOVF   57,W
1D1A:  BSF    03.6
1D1B:  MOVWF  0D
1D1C:  BSF    03.5
1D1D:  BCF    0C.7
1D1E:  BSF    0C.0
1D1F:  BCF    03.5
1D20:  MOVF   0C,W
1D21:  BCF    03.6
1D22:  SUBWF  52,W
1D23:  BTFSS  03.2
1D24:  GOTO   560
....................             if (dt.minutes == read_eeprom(21+(a*3))){  
1D25:  MOVF   3A,W
1D26:  MOVWF  65
1D27:  MOVLW  03
1D28:  MOVWF  66
1D29:  BCF    0A.4
1D2A:  BCF    0A.3
1D2B:  CALL   6AA
1D2C:  BSF    0A.4
1D2D:  BSF    0A.3
1D2E:  MOVF   78,W
1D2F:  ADDLW  15
1D30:  MOVWF  57
1D31:  BSF    03.6
1D32:  CLRF   0E
1D33:  BCF    03.6
1D34:  MOVF   57,W
1D35:  BSF    03.6
1D36:  MOVWF  0D
1D37:  BSF    03.5
1D38:  BCF    0C.7
1D39:  BSF    0C.0
1D3A:  BCF    03.5
1D3B:  MOVF   0C,W
1D3C:  BCF    03.6
1D3D:  SUBWF  51,W
1D3E:  BTFSS  03.2
1D3F:  GOTO   560
....................                if (dt.seconds <= read_eeprom(22+(a*3))){  
1D40:  MOVF   3A,W
1D41:  MOVWF  65
1D42:  MOVLW  03
1D43:  MOVWF  66
1D44:  BCF    0A.4
1D45:  BCF    0A.3
1D46:  CALL   6AA
1D47:  BSF    0A.4
1D48:  BSF    0A.3
1D49:  MOVF   78,W
1D4A:  ADDLW  16
1D4B:  MOVWF  57
1D4C:  BSF    03.6
1D4D:  CLRF   0E
1D4E:  BCF    03.6
1D4F:  MOVF   57,W
1D50:  BSF    03.6
1D51:  MOVWF  0D
1D52:  BSF    03.5
1D53:  BCF    0C.7
1D54:  BSF    0C.0
1D55:  BCF    03.5
1D56:  MOVF   0C,W
1D57:  BCF    03.6
1D58:  SUBWF  50,W
1D59:  BTFSC  03.2
1D5A:  GOTO   55D
1D5B:  BTFSC  03.0
1D5C:  GOTO   55F
....................                   //Liga a bomba  
....................                   fBomba=1;  
1D5D:  BSF    38.3
....................                } else {  
1D5E:  GOTO   560
....................                   fBomba=0;  
1D5F:  BCF    38.3
....................                }  
....................             }  
....................          }  
....................       }  
1D60:  INCF   3A,F
1D61:  GOTO   506
....................   
.................... /**************************************************************  
.................... *       OPERA A BOMBA                                         *  
.................... ***************************************************************/  
....................   
....................    //Se o estado lógico da bomba mudou... então atualiza  
....................    if (fBomba!=fBomba_old){  
1D62:  CLRF   77
1D63:  BTFSC  38.4
1D64:  BSF    77.3
1D65:  MOVF   38,W
1D66:  XORWF  77,W
1D67:  ANDLW  08
1D68:  BTFSC  03.2
1D69:  GOTO   584
....................       if (fBomba) {           //Se a bomba foi ligada!  
1D6A:  BTFSS  38.3
1D6B:  GOTO   573
....................          output_high(rele);  
1D6C:  BCF    37.1
1D6D:  MOVF   37,W
1D6E:  BSF    03.5
1D6F:  MOVWF  07
1D70:  BCF    03.5
1D71:  BSF    07.1
....................       } else {                //Se a bomba foi desligada!  
1D72:  GOTO   581
....................          output_low(rele);  
1D73:  BCF    37.1
1D74:  MOVF   37,W
1D75:  BSF    03.5
1D76:  MOVWF  07
1D77:  BCF    03.5
1D78:  BCF    07.1
....................          //Por segurança desliga as linhas tambem  
....................          output_low(linha1);  
1D79:  BSF    03.5
1D7A:  BCF    06.5
1D7B:  BCF    03.5
1D7C:  BCF    06.5
....................          output_low(linha2);  
1D7D:  BSF    03.5
1D7E:  BCF    06.4
1D7F:  BCF    03.5
1D80:  BCF    06.4
....................       }  
....................       fBomba_old=fBomba;      //Iguala para que só mude na próxima vez!  
1D81:  BCF    38.4
1D82:  BTFSC  38.3
1D83:  BSF    38.4
....................    }  
....................   
.................... /******************************************************************************  
.................... *  Funcoes especiais das teclas                                               *  
.................... *     Tecla 1 - Ajustar a hora do relogio                                     *  
.................... *     Tecla 2 - Visualizar a maxima e minima registrada                       *  
.................... ******************************************************************************/  
....................   
....................    // Se a tecla 1 estiver pressionada desvia para rotina de arrumar o relogio  
....................    if (tecla1)  
1D84:  BSF    37.2
1D85:  MOVF   37,W
1D86:  BSF    03.5
1D87:  MOVWF  07
1D88:  BCF    03.5
1D89:  BTFSC  07.2
1D8A:  GOTO   58E
....................    {  
....................       arruma_hora();  
1D8B:  BCF    0A.3
1D8C:  GOTO   18A
1D8D:  BSF    0A.3
....................    }  
....................    if (tecla2)  
1D8E:  BSF    37.3
1D8F:  MOVF   37,W
1D90:  BSF    03.5
1D91:  MOVWF  07
1D92:  BCF    03.5
1D93:  BTFSC  07.3
1D94:  GOTO   598
....................    {  
....................       max_min();  
1D95:  BCF    0A.3
1D96:  GOTO   345
1D97:  BSF    0A.3
....................    }  
....................   
....................    //Aguarda um segundo  
....................    delay_ms(800);  
1D98:  MOVLW  04
1D99:  MOVWF  57
1D9A:  MOVLW  C8
1D9B:  MOVWF  70
1D9C:  BCF    0A.4
1D9D:  BCF    0A.3
1D9E:  CALL   075
1D9F:  BSF    0A.4
1DA0:  BSF    0A.3
1DA1:  DECFSZ 57,F
1DA2:  GOTO   59A
....................   
.................... } // Fecha o While Continuo  
1DA3:  GOTO   168
.................... } // Fecha a Funcao MAIN  
....................  
1DA4:  SLEEP

Configuration Fuses:
   Word  1: 3FF1   XT NOWDT PUT NOPROTECT BROWNOUT LVP NOCPD NOWRT NODEBUG
